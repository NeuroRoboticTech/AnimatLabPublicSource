<html xmlns="http://www.w3.org/TR/REC-html40">
  <head>
    <title>Crownwood Software</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta name="resource-type" content="document" />
    <meta name="robots" content="ALL" />
    <meta name="copyright" content="Crownwood Software" />
    <meta name="author" content="Crownwood Software" />
    <meta name="description" content="Crownwood Software, DotNetMagic, Empowering the User" />
    <meta name="Content-Language" content="en-UK" />
    <meta name="Coverage" content="Worldwide" />
    <meta name="rating" content="general" />
    <link rel="stylesheet" type="text/css" href="./images/site.css" />
  </head>
  <body leftmargin="0" topmargin="0" border="0">
    <table border="0" cellpadding="0" cellspacing="0" width="775" style="background-repeat: no-repeat;">
      <tr>
        <td>
          <img src="./images/header-lhs.gif" /></td>
        <td>
          <img src="./images/header-mid.gif" /></td>
        <td>
          <img src="./images/header-rhs.gif" /></td>
      </tr>
    </table>
    <table width="775" height="100%" cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td width="160" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td height="21">
                <img src="./images/shortcut-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/shortcut-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <span class="redheading">Index</span></td>
                  </tr>
                  <tr>
                    <td width="20"></td>
                    <td height="10"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#overview">overview</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#example">example</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#tabbedgroups">tabbedgroups</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#scenario1">scenario 1</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#scenario2">scenario 2</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#scenario3">scenario 3</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td height="20">
                <img src="./images/shortcut-bottom.gif" /></td>
            </tr>
          </table></td>
        <td width="615" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="overview">TabbedGroups Advanced</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			The <i>TabbedGroups</i> control is far more versatile that it appears on first inspection. Most developers use it
			only as a way to organise documents in a similar fashion to Visual Studio .NET. Allowing the user a way to drag and
			drop their documents into a convenient arrangement. But with a little more coding effort you can also use the control
			to organise your workspace in a wide variety of ways.<p />

			This document will take you through the steps required to achieve three alternative organisations. To see these in 
			action you should run the <i>SampleTabbedAdv</i> program that shows the three scenarios we are going to build from
			the ground up. Each of the three scenarios makes use of the <i>TitleBar</i> control.  
		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="example">Example UserControl</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			Before we begin to actually code the <i>TabbedGroups</i> itself we need to create a new <i>UserControl</i>. This will
			act as the content of each working area in the scenarios that we create. Our example will contain an instance of the 
			<i>TitleBar</i> and an instance of the <i>RichTextBox</i>. The former is used as a way of providing a title to the 
			working area and also allows the user to interact with the display by also acting as a button. The <i>RichTextBox</i> 
			is used as the example of the active contents, but in your application this would something more useful such as a list, 
			tree, entry form etc.<p />

			Use the following steps to create the new <i>UserControl</i>: -<p /><UL><li>Right click your project and select <i>Add New Item...</i></li><li>Select the <i>UserControl</i> template</li><li>Enter <i>Example.cs</i> as the filename</li><li>Press <i>OK</i> to have the class created</li><li>Double click to enter design mode</li><li>Drag a <i>TitleBar</i> from ToolBox onto the design surface</li><li>Drag a <i>RichTextBox</i> from ToolBox onto the design surface</li><li>Set the <i>Size</i> of the <i>titleBar1</i> to be <i>24,24</i></li><li>Set the <i>Dock</i> property of the <i>richTextBox1</i> to be <i>Fill</i></li><li>Set the <i>BorderStyle</i> property of the <i>richTextBox1</i> to be <i>None</i></li><li>Add event handler called <i>OnArrowClick</i> for <i>titleBar1</i> event <i>ButtonClick</i></li></UL>

			By setting the <i>Size</i> of the <i>titleBar1</i> control to be <i>24,24</i> we ensure that whatever docking position
			the control is given in the future it will have the correct size. We remove the border from the <i>richTextBox1</i>
			purely because it looks prettier in the final application.<p />

			In your own application you might well create several <i>UserControl</i> implementations, with one per workarea of your
			application. In our scenarios we keep things simple by using the same class for each area as that is sufficient to 
			demonstrate the principles involved.<p />

			Add the following code to the class implementation: -<p /><pre>

   // Private field
   private EventHandler _arrowClick;

   // New constructor
   public Example(string preText, string text, string postText,
                  ArrowButton arrow, EventHandler arrowClick)
   {
      // This call is required by the Windows.Forms Form Designer.
      InitializeComponent();
			
      // Set initial values
      titleBar1.PreText = preText;
      titleBar1.Text = text;
      titleBar1.PostText = postText;
      titleBar1.ArrowButton = arrow;
			
      // Remember callback event handler
      _arrowClick = arrowClick;

      if ((arrow == ArrowButton.UpArrow) ||
          (arrow == ArrowButton.DownArrow) || 
          (arrow == ArrowButton.None))
         titleBar1.Dock = DockStyle.Top;
			
      if (arrow == ArrowButton.RightArrow)
         titleBar1.Dock = DockStyle.Right;

      if (arrow == ArrowButton.LeftArrow)
         titleBar1.Dock = DockStyle.Left;
   }

   // Fire constructor provided event user clicks titlebar arrow
   private void OnArrowClick(object sender, System.EventArgs e)
   {
      if (_arrowClick != null)
         _arrowClick.Invoke(sender, e);
   }
		
   // Allow direct access to the titlebar
   public Crownwood.DotNetMagic.Controls.TitleBar TitleBar
   {
      get { return titleBar1; }
   }

   // Allow direct access to the richtextbox
   public RichTextBox RichTextBox 
   {
      get { return richTextBox1; }
   }
		
   // Caller can discover minimum requested size
   public Size MinimumSize
   {
      get { return new Size(23, 23); }
   }

</pre>

	The new constructor is provided so that new instances can be created and setup quickly in the example
	scenarios that follow later. Inside the constructor it uses the provided <i>ArrowButton</i> value to
	determine which edge the <i>titleBar1</i> control should be docked against. It also provides an 
	<i>EventHandler</i> that needs to be called when the user clicks the arrow on the <i>titleBar1</i>
	instance. This callback allows the scenario code to alter the display when requested by the user.<p />

	To see the completed code in full just open up <i>Example.cs</i> from the <i>SampleTabbedAdv</i> project
	in the <i>C# Samples</i> solution. Alternatively open <i>Example.vb</i> from the same name project in the
	<i>VB.NET Samples</i> solution.
		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="tabbedgroups">Setting the TabbedGroups instance</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			In order to implement the steps detailed in each of the three scenarios below you need to add an instance
			of a <i>TabbedGroups</i> control to your <i>Form</i> of interest. You will also most likely want to then
			set the <i>Dock</i> property of the control to be <i>DockStyle.Fill</i> so that it occupies the entire spare
			client area on the <i>Form</i>.<p />
		
			Once added you should use the designer to set the <i>DisplayTabMode</i> to be <i>HideAll</i> as we do not want
			any tab headers to appear for any of the leafs that are inside the control. Then go to the events display in
			the properties window for the control and double click the <i>TabControlCreated</i> event. This allows you
			to perform some customization code for each <i>TabControl</i> that is created inside each leaf. Add the
			following code in the event handler: -

<pre>

   private void tabbedGroups1_TabControlCreated(
            Crownwood.DotNetMagic.Controls.TabbedGroups tg, 
            Crownwood.DotNetMagic.Controls.TabControl tc)
   {
      // Do not want borders around scenario 3 tab controls
      if (_scenario == 3)
         tc.IDEPixelBorder = false;

      // Remove the default one pixel border between positioned 
      // control and the TabControl border area
      tc.ControlLeftOffset = -1;
      tc.ControlRightOffset = -1;
      tc.ControlTopOffset = -1;
      tc.ControlBottomOffset = -1;
   }

</pre>

	For the third scenario you will need the extra line of code at the top of the routine, where <i>IDEPixelBorder</i> 
	is set to <i>False</i>. This is needed to prevent a single pixel border appearing around the edge of each leaf area.<p />

	By default you will find that the control displayed for a TabPage in a TabControl (which is inside each leaf) will
	be offset on the page. If you want to prevent the one pixel gap between the TabControl border and the page contents 
	then you must modify the <i>ControlLeftOffset</i>, <i>ControlRightOffset</i>, <i>ControlTopOffset</i> and 
	<i>ControlBottomOffset</i> properties to be -1. Try the example scenarios with and without the changes and you will 
	see the difference in practice.

		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="scenario1">Scenario 1</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>The Scenario</h2>
			Our first scenario will consist of three working areas positioned below each other in a vertical line. The
			top working area will be optional and so can be collapsed down to just a titlebar or expanded to show its 
			content as well (in our case a RichTextBox). The middle area will be mandatory and always shown as it 
			represents the user main working area. At the bottom will be another optional working area.<p />
			
			This would be useful arragement if you imagine the bottom optional area contains output messages about events that 
			are occuring. Most of the time the user does not want the client area taken up with the event list and so its 
			important they can minimize it down to just the titlebar. At other times they would like to expand it and see 
			the events. Likewise for the upper optional area, this might be used to provide other status information.<p />

			You can see this scenario in operation by running the <i>SampleTabbedAdv</i> application and selecting the first
			scenario listed under the main menu item.<p />

			Lets go through the coding steps needed to implement this situation. It is assumed you have created an instance of
			the <i>TabbedGroups</i> control within your <i>Form</i> and given it the name <i>tabbedGroups1</i>. First off we
			create a routine that will setup the scenario. This should be called once the <i>InitializeComponent</i> call has 
			finished in the constructor.<p /><h2>Creating the Scenario</h2>

			To begin we will call this routine <i>CreateScenario1</i> and start by clearing down any existing structure in
			the <i>TabbedGroups</i> instance and ensure there are 3 leafs, one for each working area requried: -<p /><pre>

   private void CreateScenario1()
   {
      // Clear out all current contents
      tabbedGroups1.RootSequence.Clear();

      // Set direction to be vertical
      tabbedGroups1.RootDirection = Direction.Vertical;
			
      // Get access to the defaulted tab left
      TabGroupLeaf tgl1 = tabbedGroups1.RootSequence[0] as TabGroupLeaf;
			
      // Add two more tab leafs
      TabGroupLeaf tgl2 = tabbedGroups1.RootSequence.AddNewLeaf();
      TabGroupLeaf tgl3 = tabbedGroups1.RootSequence.AddNewLeaf();

</pre>

		Note that when the existing contents are cleared there is still a single leaf defined because the <i>tabbedGroups1</i>
		has the <i>AtLeastOneLeaf</i> property set to <i>True</i> by default. So we get a reference to the existing first leaf
		and then create two more.<p />

		Next we need to create an instance of our <i>Example UserControl</i> for each of the working areas and add each one as
		a new <i>TabPage</i> in its respective leaf.<p /><pre>

  // Create an 'Example' for each one working area
  Example e1 = new Example("Scenario1", "Top", "Optional Area", 
                           ArrowButton.DownArrow, 
                           new EventHandler(OnArrowClick1Top));
      
  Example e2 = new Example("Scenario1", "Middle", "Mandatory Area", 
                           ArrowButton.None, null);
      
  Example e3 = new Example("Scenario1", "Bottom", "Optional Area", 
                           ArrowButton.UpArrow, 
                           new EventHandler(OnArrowClick1Bottom));
      
  // Set each one into its group leaf
  tgl1.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e1));
  tgl2.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e2));
  tgl3.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e3));

</pre>

	The first example created <i>e1</i> has an arrow that points downwards. By default we want the top area to be collapsed
	to just a titlebar and so the arrow should point down to indicate that it should be clicked to be expanded and made
	bigger. No arrow is needed on the middle area because it is always full visible. An upwards arrow is defined for the bottom
	area because it starts collapsed and we want the user to press this to expand it upwards.<p />

	So how do we control the size of the leafs? This is actually very simple and involves a combination of two properties. First
	off we can define the <i>MinimumSize</i> of each leaf so that it always displays at a minimum the titlebar. Then we define the
	value of the <i>Space</i> property for each leaf to determine how much of the left over space (after giving each leaf its 
	<i>MinimumSize</i>) each leaf gets. In our case we want the top and bottom leafs to have no extra space and the middle to have
	all of it. Therefore we set the <i>Space</i> for the top and bottom as <i>Zero</i> and the middle as <i>100</i> (percent). Here
	is the code to add this: -<p /><pre>

      // Make sure that only the last area has any space
      tgl1.Space = 0;
      tgl2.Space = 100;
      tgl3.Space = 0;
			
      // Define the minimum size of each example
      tgl1.MinimumSize = e1.MinimumSize;
      tgl2.MinimumSize = e2.MinimumSize;
      tgl3.MinimumSize = e3.MinimumSize;

      // Remember how much space top and bottom would like when expanded
      _scenario1Top = 25;
      _scenario1Bottom = 25;
			
</pre>

	The <i>_scenario1Top</i> and <i>_scenario1Bottom</i> are private fields declared as type <i>int</i> and store the requested
	percentage space the working area would like when it is expanded.<p />

	Because the top and bottom areas are collapsed we want to prevent the user from resizing them. We only allow the user to be 
	able to resize them when they are in the expanded state. So we set the <i>ResizeBarLock</i> property to <i>True</i> on the top and 
	bottom leafs to prevent the user from doing this. Here is the last of the code for the creation routine: -<p /><pre>

      // Prevent user from resizing collapses top and bottom areas
      tgl1.ResizeBarLock = true;
      tgl3.ResizeBarLock = true;
			
      // Now get them all positioned correctly
      tabbedGroups1.RootSequence.Reposition();
   }

</pre>
	
	The last action in the code is to request that leafs be repositioned to take into account the new <i>Space</i> and <i>MinimumSize</i>
	property values.<p /><h2>Manipulating the Top Area</h2>

	Now we have the initial setup we need to process the dynamic changes that occur when the user clicks the arrow button on the
	top working area. Whenever this happens the routine <i>OnArrowClick1Top</i> is called. We begin the code for this by getting
	references to the top and middle working areas which we need to manipulate: -<p /><pre>

   private void OnArrowClick1Top(object sender, System.EventArgs e)
   {
      // Get access to the top and middle areas
      TabGroupLeaf tgl1 = tabbedGroups1.RootSequence[0] as TabGroupLeaf;
      TabGroupLeaf tgl2 = tabbedGroups1.RootSequence[1] as TabGroupLeaf;

</pre>

		First we consider the situation where the top area is collapsed. We can detect if this is the case by testing if the top leaf
		has a <i>Space</i> setting of zero. If so then we perform the following processing: -<p /><pre>

      // Are we expanding the area?
      if (tgl1.Space == 0)
      {
         // How much space does top want if allowed?
         Decimal alloc = _scenario1Top;
				
         // Limit check because middle can only provide what it has
         if (alloc &gt; tgl2.Space)
            alloc = tgl2.Space;
					
         // Give top its space allocation
         tgl1.Space = alloc;
				
         // Remove allocation from middle
         tgl2.Space -= alloc;
				
         // Make arrow point upwards as next click collpases it
         (tgl1.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.UpArrow;

         // Expanded means you can resize it				
         tgl1.ResizeBarLock = false;
      }

</pre>

		Notice we are using the <i>_scenario1Top</i> field again. Here we try and set this desired percentage into the top working
		area but being careful to limit check. We have to ensure that the total for the top and middle are exactly 100 percent. 
		Next we change the direction of the arrow so that it now points upwards, meaning that when pressed it collapses the area 
		back to the top again. Last of all the <i>ResizeBarLock</i> is reset back to <i>False</i> because now it is expanded we 
		are happy to allow the user to change the relative spacing between the top and middle working areas.<p />

		Handling the reverse situation where the top area is collapsed is handled in the following way: -<p /><pre>

      else
      {
         // Remember how much space top would like when expanded
         _scenario1Top = tgl1.Space;
			
         // Realloc top space to the middle mandatory area
         tgl2.Space += tgl1.Space;
				
         // Collapse the top
         tgl1.Space = 0;

         // Make arrow point downwards as next click expands it
         (tgl1.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.DownArrow;

         // Collapsed means you cannot resize it				
         tgl1.ResizeBarLock = true;
      }
			
      // Reflect changes immediately
      tabbedGroups1.RootSequence.Reposition();
   }

</pre>

	The first line of code saves the current spacing value so that when the top area is expanded again it can be put back to
	the same size again. It reallocates the removed space into the mandatory middle area and then puts the arrow back to be
	downwards pointing. Now the area is collapsed the <i>ResizeBarLock</i> can be locked again to prevent user changes.<p />
	
	Lastly we call <i>Reposition</i> so that changes in spacing are reflected immediately.

			<h2>Manipulating the Bottom Area</h2>

	The code for handling the bottom working area is almost the same as for the top. Here is the entire code for the 
	<i>OnArrowClick1Bottom</i> event processing: -<p /><pre>

   private void OnArrowClick1Bottom(object sender, System.EventArgs e)
   {
      // Get access to the middle and bottom areas
      TabGroupLeaf tgl2 = tabbedGroups1.RootSequence[1] as TabGroupLeaf;
      TabGroupLeaf tgl3 = tabbedGroups1.RootSequence[2] as TabGroupLeaf;
		
      // Are we expanding the area?
      if (tgl3.Space == 0)
      {
         // How much space does bottom want if allowed?
         Decimal alloc = _scenario1Bottom;
				
         // Limit check because middle can only provide what it has
         if (alloc &gt; tgl2.Space)
            alloc = tgl2.Space;
					
         // Give bottom its space allocation
         tgl3.Space = alloc;
				
         // Remove allocation from middle
         tgl2.Space -= alloc;
				
         // Make arrow point upwards as next click collapses it
         (tgl3.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.UpArrow;

         // Expanded means you can resize it				
         tgl3.ResizeBarLock = false;
      }
      else
      {
         // Remember how much space bottom would like when expanded
         _scenario1Top = tgl3.Space;
			
         // Realloc bottom space to the middle mandatory area
         tgl2.Space += tgl3.Space;
				
         // Collapse the bottom
         tgl3.Space = 0;

         // Make arrow point downwards as next click expands it
         (tgl3.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.DownArrow;

         // Collapsed means you cannot resize it				
         tgl3.ResizeBarLock = true;
      }
			
      // Reflect changes immediately
      tabbedGroups1.RootSequence.Reposition();
   }

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="scenario2">Scenario 2</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>The Scenario</h2>
			Our second scenario is a variation from the first one. Instead of having all three working areas in a vertical
			line we change this around slightly. This time there is an optional area on the left hand side and two areas placed
			one above the other on the right. The left and bottom working areas are optional and the top area in mandatory.

			You can see this scenario in operation by running the <i>SampleTabbedAdv</i> application and selecting the second
			scenario listed under the main menu item.<p />

			Lets go through the coding steps needed to implement this situation. It is assumed you have created an instance of
			the <i>TabbedGroups</i> control within your <i>Form</i> and given it the name <i>tabbedGroups1</i>. First off we
			create a routine that will setup the scenario. This should be called once the <i>InitializeComponent</i> call has 
			finished in the constructor.<p /><h2>Creating the Scenario</h2>

			To begin we will call this routine <i>CreateScenario2</i> and start by clearing down any existing structure in
			the <i>TabbedGroups</i> instance. This time we need to add a new sequence that will contain the two right hand
			side leafs and then place this new sequence after the existing left hand leaf. The code looks like this: -<p /><pre>

   private void CreateScenario2()
   {
      // Clear out all current contents
      tabbedGroups1.RootSequence.Clear();
			
      // Set direction to be Horizontal
      tabbedGroups1.RootDirection = Direction.Horizontal;
			
      // Get access to the defaulted tab left
      TabGroupLeaf tgl1 = tabbedGroups1.RootSequence[0] as TabGroupLeaf;
			
      // Create a new sequence for holding two verical groups
      TabGroupSequence tgs1 = tabbedGroups1.RootSequence.AddNewSequence();
			
      // Add two more tab leafs to the new sequence
      TabGroupLeaf tgl2 = tgs1.AddNewLeaf();
      TabGroupLeaf tgl3 = tgs1.AddNewLeaf();

</pre>

		Unlike the first scenario we set the <i>RootDirection</i> to be <i>Horizontal</i> because we need the left hand leaf
		and then the new sequence to be positioned across the display. Adding the two new leafs to the new sequence is very
		straightforward and will look similar to the code from the previous scenario.<p /><pre>

 // Create a 'Example' for each one
 Example e1 = new Example("Scenario2", "Left", "Optional Area", 
                          ArrowButton.RightArrow, 
                          new EventHandler(OnArrowClick2Left));

 Example e2 = new Example("Scenario2", "Top", "Mandatory Area", 
                          ArrowButton.None, null);

 Example e3 = new Example("Scenario2", "Bottom", "Optional Area", 
                          ArrowButton.UpArrow, 
                          new EventHandler(OnArrowClick2Bottom));
			
 // Set each one into its group leaf
 tgl1.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e1));
 tgl2.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e2));
 tgl3.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e3));
			
</pre>

	Creating and adding the <i>Example</i> instances as leafs is simple enough and looks almost the same as in the first
	scenario. Notice however that the first <i>Example</i> called <i>e1</i> has its <i>ArrowButton</i> set to 
	<i>RightArrow</i> because it is positioned along the left hand side and will expand towards the right.<p />

	The rest of the code to complete the routine is as follows: -<p /><pre>

      // Make sure that only the last area has any space
      tgl1.Space = 0;
      tgs1.Space = 100;
      tgl2.Space = 100;
      tgl3.Space = 0;
			
      // Define the minimum size of each example
      tgl1.MinimumSize = e1.MinimumSize;
      tgl2.MinimumSize = e2.MinimumSize;
      tgl3.MinimumSize = e3.MinimumSize;

      // Remember how much space left and bottom would like when expanded
      _scenario2Left = 25;
      _scenario2Bottom = 25;
			
      // Prevent user from resizing collapses top and bottom areas
      tgl1.ResizeBarLock = true;
      tgl3.ResizeBarLock = true;

      // Now get them all positioned correctly
      tabbedGroups1.RootSequence.Reposition();
   }

</pre>

	When setting the initial <i>Space</i> values we need to take into account the extra sequence that was created. So the
	left and bottom leafs are set to have <i>Zero</i> space because they begin collapsed. The new sequence has 100 percent
	of the top level space because the left leaf has none. The mandatory top leaf has 100 percent space because the other
	leaf in the sequence, the bottom leaf, has no space at all. The rest of the code will look familiar from the first 
	scenario.<p /><h2>Manipulating the Left Area</h2>

	Now we have the setup complete we need to process the dynamic changes that occur when the user clicks the arrow button on the
	left working area. Whenever this happens the routine <i>OnArrowClick2Left</i> is called. The code for the entire routine is as 
	follows: -<p /><pre>

   private void OnArrowClick2Left(object sender, System.EventArgs e)
   {
      // Get access to the left and right areas
      TabGroupLeaf tgl1 = tabbedGroups1.RootSequence[0] as TabGroupLeaf;
      TabGroupSequence tgs1 = tabbedGroups1.RootSequence[1] as TabGroupSequence;

      // Are we expanding the area?
      if (tgl1.Space == 0)
      {
         // Give left its space allocation
         tgl1.Space = _scenario2Left;

         // Remove allocation from right
         tgs1.Space -= _scenario2Left;

         // Make arrow point left as next click collpases it
         (tgl1.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.LeftArrow;

         // Expanded means you can resize it
         tgl1.ResizeBarLock = false;
      }
      else
      {
         // Remember how much space left would like when expanded
         _scenario2Left = tgl1.Space;

         // Realloc top space to the right area
         tgs1.Space += tgl1.Space;

         // Collapse the top
         tgl1.Space = 0;

         // Make arrow point downwards as next click expands it
         (tgl1.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.RightArrow;

         // Collapsed means you cannot resize it
         tgl1.ResizeBarLock = true;
      }

      // Reflect changes immediately
      tabbedGroups1.RootSequence.Reposition();
   }

</pre>

	There are only two points of difference between this event handler and the one for the top working area in the 
	first scenario. First off the mandatory area that was manipulated in the first scenario is replaced with the 
	new sequence that was created in the second scenario. You can see this in the second line of code that gets
	a reference to that new sequence. Second is the change from up and down arrows to using left and right arrows
	instead.<p /><h2>Manipulating the Bottom Area</h2>

	Handling the bottom area is the same here as it was in the first scenario. We just used slightly different code
	to navigate to the leaf references at the beginning. For the sake of completeness here is the entire routine: -<p /><pre>

   private void OnArrowClick2Bottom(object sender, System.EventArgs e)
   {
      TabGroupSequence tgs1 = tabbedGroups1.RootSequence[1] as TabGroupSequence;
	
      // Get access to the middle and bottom areas
      TabGroupLeaf tgl2 = tgs1[0] as TabGroupLeaf;
      TabGroupLeaf tgl3 = tgs1[1] as TabGroupLeaf;
	
      // Are we expanding the area?
      if (tgl3.Space == 0)
      {
         // Give bottom its space allocation
         tgl3.Space = _scenario2Bottom;
			
         // Remove allocation from top
         tgl2.Space -= _scenario2Bottom;
			
         // Make arrow point upwards as next click collapses it
         (tgl3.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.UpArrow;

         // Expanded means you can resize it
         tgl3.ResizeBarLock = false;
		}
      else
      {
         // Remember how much space bottom would like when expanded
         _scenario2Bottom = tgl3.Space;
		
         // Realloc bottom space to the top mandatory area
         tgl2.Space += tgl3.Space;
			
         // Collapse the bottom
         tgl3.Space = 0;

         // Make arrow point downwards as next click expands it
         (tgl3.TabPages[0].Control as Example).TitleBar.ArrowButton = 
                                                         ArrowButton.DownArrow;

         // Collapsed means you cannot resize it
         tgl3.ResizeBarLock = true;
      }
		
      // Reflect changes immediately
      tabbedGroups1.RootSequence.Reposition();
      tgs1.Reposition();
   }

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="scenario3">Scenario 3</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>The Scenario</h2>
			Our third scenario deviates the most from the standard use of the <i>TabbedGroups</i> control. In this case we are
			going to create a vertical list of working areas but where only a single one is visible at any point in time. This is
			quite similar in operation to the Visual Studio .NET Toolbox control. Clicking on the titlebar for any of the working
			areas will cause that area to be fully expanded and the others to be collapsed.<p />

			You can see this scenario in operation by running the <i>SampleTabbedAdv</i> application and selecting the third
			scenario listed under the main menu item.<p />

			Lets go through the coding steps needed to implement this situation. It is assumed you have created an instance of
			the <i>TabbedGroups</i> control within your <i>Form</i> and given it the name <i>tabbedGroups1</i>. First off we
			create a routine that will setup the scenario. This should be called once the <i>InitializeComponent</i> call has 
			finished in the constructor.<p /><h2>Creating the Scenario</h2>

			To begin we will call this routine <i>CreateScenario3</i> and start by clearing down any existing structure in
			the <i>TabbedGroups</i> instance. Look at the code below and you will see that in addition to the default leaf
			another four are created in a vertical arragement: -<p /><pre>

   private void CreateScenario3()
   {
      // Clear out all current contents
      tabbedGroups1.RootSequence.Clear();

      // Set direction to be vertical
      tabbedGroups1.RootDirection = Direction.Vertical;
			
      // Get access to the defaulted tab left
      TabGroupLeaf tgl1 = tabbedGroups1.RootSequence[0] as TabGroupLeaf;
			
      // Add several more leafs
      TabGroupLeaf tgl2 = tabbedGroups1.RootSequence.AddNewLeaf();
      TabGroupLeaf tgl3 = tabbedGroups1.RootSequence.AddNewLeaf();
      TabGroupLeaf tgl4 = tabbedGroups1.RootSequence.AddNewLeaf();
      TabGroupLeaf tgl5 = tabbedGroups1.RootSequence.AddNewLeaf();

</pre>

	Next we create the five different <i>Example</i> instances that are needed to fill each of the five new leafs. None of
	them is given an arrow direction as we want the control to simply be pressed to make it the active and expanded one.<p /><pre>

  // Create a 'Example' for each one
  Example e1 = new Example("Scenario3", "One", string.Empty, 
                           ArrowButton.None, 
                           new EventHandler(OnTitleClick3));
   
  Example e2 = new Example("Scenario3", "Two", string.Empty, 
                           ArrowButton.None, 
                           new EventHandler(OnTitleClick3));

  Example e3 = new Example("Scenario3", "Three", string.Empty, 
                           ArrowButton.None, 
                           new EventHandler(OnTitleClick3));

  Example e4 = new Example("Scenario3", "Four", string.Empty, 
                           ArrowButton.None, 
                           new EventHandler(OnTitleClick3));

  Example e5 = new Example("Scenario3", "Five", string.Empty, 
                           ArrowButton.None, 
                           new EventHandler(OnTitleClick3));
			
  // Set each one into its group leaf
  tgl1.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e1));
  tgl2.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e2));
  tgl3.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e3));
  tgl4.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e4));
  tgl5.TabPages.Add(new Crownwood.DotNetMagic.Controls.TabPage(string.Empty, e5));
			
</pre>

	Lets make the fourth leaf the one that is active at startup. So we set the <i>Space</i> value of the fourth leaf to be
	100 percent and all the others to <i>Zero</i> percent. We also need to prevent the user from using any of the resizing
	bars between the leafs and so set the <i>ResizeBarLock</i> property to <i>True</i> for all leaf.<p /><pre>

      // Make sure that only the last area has any space
      tgl1.Space = 0;
      tgl2.Space = 0;
      tgl3.Space = 0;
      tgl4.Space = 100;
      tgl5.Space = 0;

      // Define the minimum size of each example
      tgl1.MinimumSize = e1.MinimumSize;
      tgl2.MinimumSize = e2.MinimumSize;
      tgl3.MinimumSize = e3.MinimumSize;
      tgl4.MinimumSize = e3.MinimumSize;
      tgl5.MinimumSize = e3.MinimumSize;

      // Prevent user from resizing			
      tgl1.ResizeBarLock = true;
      tgl2.ResizeBarLock = true;
      tgl3.ResizeBarLock = true;
      tgl4.ResizeBarLock = true;
      tgl5.ResizeBarLock = true;

</pre>

	Next we set the titlebar for each leaf so that the whole control acts like a button. So when the user presses 
	anywhere on the control we want to be notified so we can make that leaf the active one. Then we need to change
	the <i>Active</i> proprety to <i>False</i> for all except the fourth leaf. This changes the visual appearance so that
	all except the currently active one are dimmed slightly.<p /><pre>

      // Make entire titlebar act as a button
      e1.TitleBar.ActAsButton = ActAsButton.WholeControl;
      e2.TitleBar.ActAsButton = ActAsButton.WholeControl;
      e3.TitleBar.ActAsButton = ActAsButton.WholeControl;
      e4.TitleBar.ActAsButton = ActAsButton.WholeControl;
      e5.TitleBar.ActAsButton = ActAsButton.WholeControl;

      // Only the currently selected one should be active
      e1.TitleBar.Active = false;
		e2.TitleBar.Active = false;
		e3.TitleBar.Active = false;
		e5.TitleBar.Active = false;

      // Now get them all positioned correctly
      tabbedGroups1.RootSequence.Reposition();
   }

</pre><h2>Changing the Active Leaf</h2>

	Rather than replicate almost the same code five times we use the same event handler to handle the click from each of 
	the five titlebars. The first action of the routine is to find the leaf index of the titlebar that generated the event.
	This is achieved by using a simple loop to test each leaf in turn until the matching entry is found.<p /><pre>

   private void OnTitleClick3(object sender, System.EventArgs e)
   {
      // Remember which title bar sent message
      TitleBar tbClick = sender as TitleBar;
		
      int index = 0;
			
      // Start search from the first leaf
      TabGroupLeaf tgl = tabbedGroups1.FirstLeaf();
			
      // Keep going till be get a match...
      while(tgl != null)
      {
         // Extract the example instance from page
         TitleBar tb = (tgl.TabPages[0].Control as Example).TitleBar;
			
         // Is the source of the click?
         if (tb == tbClick)
            break;
					
         // Move on to the next leaf in turn
         tgl = tabbedGroups1.NextLeaf(tgl);

         // Track index of found entry
         index++;
      }

</pre>

	Then we use another loop to process each leaf in turn. If the leaf is the newly selected one then we set the <i>Active</i>
	value to <i>True</i> and give it a <i>Space</i> value 100 percent. Otherwise it must be inactive and so given <i>Space</i>
	of <i>Zero</i> and <i>Active</i> property value of <i>False</i>.<p /><pre>

      int test = 0;
			
      // Process all leafs again from begining
      tgl = tabbedGroups1.FirstLeaf();
			
      // Keep going till be get a match...
      while(tgl != null)
      {
         // Extract the example instance from page
         TitleBar tb = (tgl.TabPages[0].Control as Example).TitleBar;

         // Set active state depending on if it was the one clicked
         tb.Active = (index == test);
				
         // Set space depending on it it was the one clicked		
         tgl.Space = (index == test) ? 100 : 0;	
					
         // Move on to the next leaf in turn
         tgl = tabbedGroups1.NextLeaf(tgl);

         // Track index of found entry
         test++;
      }

      // Reflect changes immediately
      tabbedGroups1.RootSequence.Reposition();
   }

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
          </table></td>
      </tr>
    </table>
    <div style="position:absolute; left:20px; top:132px;">
      <a href="../readme.html" class="white">ReadMe</a>
      <span class="cyan">| </span>
      <a href="articles.html" class="white">Articles</a>
      <span class="cyan">| </span>
      <a href="contact.html" class="white">Contact</a>
    </div>
    <div style="position:absolute; left:620px; top:132px; text-align:right;">
      <span class="whitebold">Empowering the User</span>
    </div>
  </body>
</html>
