<html xmlns="http://www.w3.org/TR/REC-html40">
  <head>
    <title>Crownwood Software</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta name="resource-type" content="document" />
    <meta name="robots" content="ALL" />
    <meta name="copyright" content="Crownwood Software" />
    <meta name="author" content="Crownwood Software" />
    <meta name="description" content="Crownwood Software, DotNetMagic, Empowering the User" />
    <meta name="Content-Language" content="en-UK" />
    <meta name="Coverage" content="Worldwide" />
    <meta name="rating" content="general" />
    <link rel="stylesheet" type="text/css" href="./images/site.css" />
  </head>
  <body leftmargin="0" topmargin="0" border="0">
    <table border="0" cellpadding="0" cellspacing="0" width="775" style="background-repeat: no-repeat;">
      <tr>
        <td>
          <img src="./images/header-lhs.gif" /></td>
        <td>
          <img src="./images/header-mid.gif" /></td>
        <td>
          <img src="./images/header-rhs.gif" /></td>
      </tr>
    </table>
    <table width="775" height="100%" cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td width="160" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td height="21">
                <img src="./images/shortcut-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/shortcut-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <span class="redheading">Index</span></td>
                  </tr>
                  <tr>
                    <td width="20"></td>
                    <td height="10"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#overview">overview</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#creatingobjects">creating</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#classes">classes</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#simple">simple</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#processleafs">process leafs</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#complex">complex</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#userinterface">user interface</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#persistence">persistence</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#notifications">notifications</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#externaldrag">external drag</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td height="20">
                <img src="./images/shortcut-bottom.gif" /></td>
            </tr>
          </table></td>
        <td width="615" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="overview">TabbedGroups Overview</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>Tabbed MDI</h2>
            When using <i>Visual Studio .NET</i> you will have noticed that it offers an alternative to the 
            traditional <i>SDI</i> or <i>MDI</i> user interface. The <i>Tabbed MDI</i> mode presents a tab control 
            appearance with an individual tab per open document. It also allows the creation of additional groups, 
            either vertically or horizontally. The <i>TabbedGroups</i> control is intended to offer this same style 
            of organising your workspace.<p /><h2>Beyond Tabbed MDI</h2><p />
            The <i>Visual Studio .NET</i> implementation only allows a single sequence of groups in either the vertical 
			or horizontal direction. Once you create your second group in a specific direction all the subsequent groups 
			must also be ordered in that same direction. The <i>TabbedGroups</i> control does not have this restriction. You 
			can create a sequence of groups in one direction and then embed another sequence in the opposite direction within it. 
			In fact there is no limit to the complexity or depth of the hierachy that can be created. This provides far greater 
			flexibility in the laying out of your workspace. Try experimenting with the provided <i>SampleTabbedGroups</i>
			application to see how easy it is to create and manipulate your workspace.<p /><h2>User Interface</h2>
			Using the <i>TabbedGroups</i> control at runtime is very easy. You can reorganise the layout by just dragging a tab page 
			header and then moving it to a new position. When dragging within the control you will notice a drag rectangle is drawn to 
			indicate the action that will occur should you drop the page at the specified cursor location. If the rectangle covers an 
			entire tab group then it shows the page will be added to the indicated collection of pages. If the cursor is placed towards 
			the edge of an existing group then it will indicate a smaller rectangle, this shows where a new group will be created with the
			dragged page placed within it.<p />
			
			Between each tab group is a small resize bar that is used to change the size of groups. Place the cursor over the resize bar 
			and it will change shape to indicate a resize operation is available. Use the right mouse button to click and drag this bar in
			order to change the size of the groups on either side. A drag bar will be shown during the dragging operation to show where the 
			new divide between the groups will be.<p />
			
            Right-clicking a selected tab will cause a context menu to be shown. This menu gives the user quick access to all the options
            needed to manage the workspace. Options exist to move the selected page into a new group of its own, move the page into the 
            next or previous existing groups, close the page, toggle the prominent setting or to reset the spacing of groups. All of these
            actions are available without the use of the menu. Either by dragging the page around or using the shortcut key combinations.<p /><h2>Proportional Spacing</h2>
            When more than one group is present you can use the resizing bar between groups in order to change the relative spacing of
            the displayed groups. As you resize your application this proportional spacing is honored. So if you have two groups that
            take up half the width each and then resize the whole <i>TabbedGroups</i> control, it will ensure that both groups are resized 
            so they still occupy half the space. If one of the groups has 25% percent of the width and the other the remaining 75% then 
            this aspect ratio is maintained as the user resizes the control.<p />
            
            In a real world application you will find that there is a minimum size required for some of your groups. Allowing a group to be 
            sized smaller than the minimum does not make sense because the group would become unusable. By assigning an appropriate minimum
            size to your groups it is possible to ensure that proportional spacing takes effect but it will not reduce the size of any
            group below the minimum usable threshold.<p />

			If you need to prevent the user from changing the proportional spacing because your application needs to keep it fixed then
			you can set the <i>ResizeBarLock</i> property. You can also set the <i>LayoutLock</i> property if you also want to prevent the
			user from moving tab pages around the control. By setting both you effectively lock the current layout of groups and their proportional
			spacing from user interference.<p /><h2>Prominent Mode</h2>
			The prominent mode is very similar in concept of allowing an MDI child window to be maximized. Using the tab page context menu
			or appropriate shortcut key combination will cause that group to become the prominent group. This will cause the group to occupy
			the majority of the control space. Use the context menu or key combination a second time in order to restore the display to
			its normal state. By default the other groups will not be completely hidden from view but instead sized to their minimums. You
			can always set the <i>ProminentOnly</i>	property to ensure that only the prominent group is shown in this mode.<p />

			The following sections show how to use the control and describe the more important 
			properties and events for controlling the <I>TabbedGroups</I>. This is not however 
			an exhaustive list and so the help document should be consulted for the 
			definitive list of all functionality.
</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="creatingobjects">Creating your TabbedGroups</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>Creating your TabbedGroups from the Toolbox</h2>
                              <p />
            You can drag <i>TabbedGroups</i> instances from the toolbox onto your design surface and 
            then define its operating properties. Note that you cannot however manipulate and design the
            actual runtime set of groups. This is not the setback it might first appear as the majority of
            applications dynamically manipulate the control and so have little to do at design time except
            define a few control properties.<p />
			
			If the control is not already present in the toolbox then you will need to add the control 
			by right-clicking the toolbox window and selecting the <i>Add/Remove items...</i> option.

            Navigate to the installation directory called <i>Bin</i> and select the <i>DotNetMagic2005.dll</i>
			library.

            The toolbox will now list the extra controls that are exposed by the library 
            including the <i>TabbedGroups</i>.<p /><h2>Creating your TabbedGroups manually</h2><p />

            If you need to create your <i>TabbedGroups</i> manually then use the following simple example: -<p /><code>C#</code><pre>

   Crownwood.DotNetMagic.Controls.TabbedGroups tg = 
      new Crownwood.DotNetMagic.Controls.TabbedGroups();

</pre><code>VB.NET</code><pre>

   Dim tg As New Crownwood.DotNetMagic.Controls.TabControl()

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="classes">Classes</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>Group Hierarchy</h2>
			The control contains a hierarchy of objects that describe the layout of the tab groups displayed. In order to navigate around this
			tree hierarchy or to programmatically manipulate it you will need to understand two classes. The <i>TabGroupLeaf</i> class represents
			a group that can contain <i>TabPages</i> and the <i>TabGroupSequence</i> class organises the positioning of its child groups.<p /><h2>TabGroupLeaf Class</h2>
		    This class implements an instance of the <i>TabControl</i> and as the name implies, instances should only ever occur as leaf nodes
		    in the hierarchy of groups. To add new pages to an instance of this class you need only interact with the <i>TabGroupLeaf.TabPages</i>
		    property which exposes the collection of tab pages from the underlying <i>TabControl</i> instance. If you need to access the actual 
			<i>TabControl</i> directly then you can use the <i>TabGroupLeaf.TabControl</i> property.<p /><h2>TabGroupSequence Class</h2>
		    This class contains a collection of other groups. Each child group could be either a <i>TabGroupLeaf</i> or another <i>TabGroupSequence</i> 
			that represents an embedded sequence of groups. This flexibility to contain a sequence within another sequence allows any level of complexity 
			to be achieved.<p /><h2>TabGroupBase Class</h2>		    
		    Both of the above classes derive from the base class called <i>TabGroupBase</i>. At times you may have a reference to the base class and 
		    need to discover the actual derived class it represents. A quick way of doing this is to use the properties <i>TabGroupBase.IsLeaf</i> and 
		    <i>TabGroupBase.IsSequence</i> and then cast the reference as appropriate.<p /><h2>Root Sequence</h2>
		    The starting point for the group hierarchy is the <i>TabbedGroups.RootSequence</i> property which exposes the top level sequence of 
		    groups from the control instance as an instance of the <i>TabGroupSequence</i> class. Another point to remember is that you should never 
			create instances of leafs or sequences directly but instead use the appropriate methods exposed by existing groups in the hierarchy.<p />

			A new <i>TabbedGroups</i> instance will begin with just a single tab group created. So the <i>TabbedGroups.RootSequence</i> will contain
			just a single child which is an instance of the <i>TabGroupLeaf</i> class. This leaf will not contain any tab pages. This is always the 
			starting point for manipulating your control at runtime. It is easy to restore the control to this initial state at any time by removing
			all the children of the root sequence. <p /><code>C#</code><pre>

   tabbedGroup.RootSeequence.Clear();

</pre><code>VB.NET</code><pre>

   tabbedGroup.RootSeequence.Clear()

</pre>

			Having just used the <i>Clear()</i> method on the root sequence you would have thought that it would contain no child groups at all. Therefore 
			it would not match the initial state of the control when created that has a single leaf group. This is not the case because of a property called 
			<i>AtLeastOneLeaf</i> that is defined as <i>True</i> by default. As the name implies, the property is used to ensure that after any change to the 
			structure of the group hierarchy there always remains at least one leaf group. If you think about it then this makes sense because the control is
			going to be almost useless if there are no leafs at all. You can always define the property to be <i>False</i> if you have an unusual need that
			requires this functionality but all the examples that follow will assume that it is set.<p />

			Another reason for keeping the default setting of <i>AtLeastOneLeaf</i> is the way that a leaf group will automatically delete itself when the last
			tab page of the leaf is closed down. When the last page is removed from a leaf it makes sense to kill the leaf itself because it no longer has any
			contents to display. So if you remove the last page on the only leaf then using this property will ensure that the last leaf is not deleted.<p />

			The important point to remember is that calling <i>Clear()</i> on the root sequence results in the existence of a single leaf group.<p /></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="simple">Creating a simple hierarchy</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			One of the simplest organisations we can create is to split the control into two leaf groups that are positioned the full height of the control
			but splitting the horizontal space. We can use the <i>Clear()</i> method on the root sequence to reduce the current state of the control to a
			single child leaf. So all our additional code needs to do is add another leaf and then add a single tab page for each leaf. All examples place a 
			<i>RichTextBox</i> into the example tab page instances but your own application would provide a more appropriate content.<p /><code>C#</code><pre>

   // Reduce to a known state
   tabbedGroup.RootSequence.Clear();

   // Get reference to the first leaf
   TabGroupLeaf leaf1 = tabbedGroup.RootSequence[0] as TabGroupLeaf;

   // Create new leaf at end of current sequence 
   TabGroupLeaf leaf2 = tabbedGroup.RootSequence.AddNewLeaf();
    
   // Add a tab page to each new leaf
   leaf1.TabPages.Add(new TabPage("Page1", new RichTextBox());
   leaf2.TabPages.Add(new TabPage("Page2", new RichTextBox());

</pre><code>VB.NET</code><pre>

   ' Reduce to a known state
   tabbedGroup.RootSequence.Clear()

   ' Get reference to the first leaf
   Dim leaf1 As TabGroupLeaf  = CType(tabbedGroup.RootSequence[0], TabGroupLeaf)

   ' Create new leaf at end of current sequence 
   Dim leaf2 As TabGroupLeaf = tabbedGroup.RootSequence.AddNewLeaf()
    
   ' Add a tab page to each new leaf
   leaf1.TabPages.Add(New TabPage("Page1", New RichTextBox())
   leaf2.TabPages.Add(New TabPage("Page2", New RichTextBox())

</pre>

		By default the root sequence will position its children in a horizontal direction and from left to right. If you need to
		order the children in a vertical direction from top to bottom then you need to modify the example code to set the correct
		direction after the current state has been reset.<p /><code>C#</code><pre>

   // Reduce to a known state
   tabbedGroup.RootSequence.Clear();

   // Position children from top to bottom 
   tabbedGroup.RootSequence.Direction = Direction.Vertical;

   // Get reference to the first leaf
   TabGroupLeaf leaf1 = tabbedGroup.RootSequence[0] as TabGroupLeaf;

   // Create new leaf at end of current sequence 
   TabGroupLeaf leaf2 = tabbedGroup.RootSequence.AddNewLeaf();
    
   // Add a tab page to each new leaf
   leaf1.TabPages.Add(new TabPage("Page1", new RichTextBox());
   leaf2.TabPages.Add(new TabPage("Page2", new RichTextBox());

</pre><code>VB.NET</code><pre>

   ' Reduce to a known state
   tabbedGroup.RootSequence.Clear()

   ' Position children from top to bottom 
   tabbedGroup.RootSequence.Direction = Direction.Vertical

   ' Get reference to the first leaf
   Dim leaf1 As TabGroupLeaf  = CType(tabbedGroup.RootSequence[0], TabGroupLeaf)

   ' Create new leaf at end of current sequence 
   Dim leaf2 As TabGroupLeaf = tabbedGroup.RootSequence.AddNewLeaf()
    
   ' Add a tab page to each new leaf
   leaf1.TabPages.Add(New TabPage("Page1", New RichTextBox())
   leaf2.TabPages.Add(New TabPage("Page2", New RichTextBox())

</pre>

	When you add a new sequence by using the <i>AddNewSequence</i> method it will automatically set the direction of the new
	sequence to be the opposite of the parent sequence. So if the parent is <i>Vertical</i> then the new sequence will be 
	<i>Horizontal</i> and vica versa. It obviously makes no sense to create an child sequence in the same direction as the parent.
	In fact the control will optimize the situation away and compact the child sequence into the parent in order to keep the 
	hierarchy as flat and simple as possible.<p /><h2>The Active Leaf</h2>
	As long as there is at least one <i>TabGroupLeaf</i> instance then there will always be an active leaf. The active leaf
	is the one that last had the focus. You can use the <i>TabbedGroups.ActiveLeaf</i> property to discover which leaf is
	the currently active one and hook into the <i>ActiveLeafChanged</i> event for notification when it changes. This is useful 
	when you need to create and add a new document to the control. In this situation you should add the new page to the 
	currently active leaf rather than always using the first leaf that you can find.<p /></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="processleafs">Processing leafs</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
		Moving around the set of leaf elements is made easier by the provision of the following set of useful helper methods. You
		can use <i>TabbedGroups.FirstLeaf</i> and <i>TabbedGroups.LastLeaf</i> to return a reference to the first and last
		leaf instances in the hierarchy. When you already have a leaf reference you can use <i>TabbedGroups.NextLeaf</i> and
		<i>TabbedGroups.PreviousLeaf</i> to move to the next and previous leafs respectively. Note that these last two methods do 
		not wrap around the total collection of leafs and so will return <i>null/</i> when they reach either the start or end as 
		appropriate. You can construct a simple loop to process each leaf node in the hierarchy without having to know how the 
		hierarchy is organised.<p /><code>C#</code><pre>

   // Get first leaf
   TabGroupLeaf leaf = tabbedGroup.FirstLeaf();
   
   while(leaf != null)
   {
      // Process leaf
      (do something application specific here...)	
      
      // Move to next leaf
      leaf = tabbedGroup.NextLeaf(leaf);
   }

</pre><code>VB.NET</code><pre>

   ' Get first leaf
   Dim leaf as TabGroupLeaf = tabbedGroup.FirstLeaf()
   
   While Not leaf is Nothing
      ' Process leaf
      (do something application specific here...)	
      
      ' Move to next leaf
      leaf = tabbedGroup.NextLeaf(leaf)
   End While

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="complex">Creating a complex hierarchy</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			A real world application is likely to need a more complex arrangement than that given in the simple example above. So here
			we are going to define a hierarchy that consists of two rows of groups. The top row will have two leafs where the left leaf
			takes up two thirds of the width and the right leaf takes up the remaining third. On the second row will be three leafs that 
			are equally spaced out. This arrangement will therefore demonstrate how to create child sequences and also how to modify the
			starting proportional spacing of leafs within a sequence.<p />

			After resetting the state of the control we then need to manually add two new sequences as children of the root sequence. The 
			first of these will have two leafs added and the second sequence will have three leafs added to it. We add a tab page to each
			of the new leafs to represent the application content. Your application could of course add more than just a single page to 
			the leafs if required. Finally we need to remove that single leaf that is automatically added as part of the reset.<p /><code>C#</code><pre>

   // Reduce to a known state
   tabbedGroup.RootSequence.Clear();

   // Position children from top to bottom 
   tabbedGroup.RootSequence.Direction = Direction.Vertical;

   // Create the two new sequences inside the root
   TabGroupSequence s1 = tabbedGroup.RootSequence.AddNewSequence();
   TabGroupSequence s2 = tabbedGroup.RootSequence.AddNewSequence();
    
   // Add two leafs into first sequence
   TabGroupLeaf s1l1 = s1.AddNewLeaf();
   TabGroupLeaf s1l2 = s1.AddNewLeaf();

   // Add three leafs into second sequence
   TabGroupLeaf s2l1 = s2.AddNewLeaf();
   TabGroupLeaf s2l2 = s2.AddNewLeaf();
   TabGroupLeaf s2l3 = s2.AddNewLeaf();

   // Add a tab page to each new leaf
   s1l1.TabPages.Add(New TabPage("Page1", new RichTextBox());
   s1l2.TabPages.Add(New TabPage("Page2", new RichTextBox());
   s2l1.TabPages.Add(New TabPage("Page3", new RichTextBox());
   s2l2.TabPages.Add(New TabPage("Page4", new RichTextBox());
   s2l3.TabPages.Add(New TabPage("Page5", new RichTextBox());

   // Remove the single child leaf
   tabbedGroup.RootSequence.RemoveAt(0);

</pre><code>VB.NET</code><pre>

   ' Reduce to a known state
   tabbedGroup.RootSequence.Clear()

   ' Position children from top to bottom 
   tabbedGroup.RootSequence.Direction = Direction.Vertical

   ' Create the two new sequences inside the root
   Dim s1 As TabGroupSequence = tabbedGroup.RootSequence.AddNewSequence()
   Dim s2 As TabGroupSequence = tabbedGroup.RootSequence.AddNewSequence()
    
   ' Add two leafs into first sequence
   Dim s1l1 As TabGroupLeaf = s1.AddNewLeaf()
   Dim s1l2 As TabGroupLeaf = s1.AddNewLeaf()

   ' Add three leafs into second sequence
   Dim s2l1 As TabGroupLeaf = s2.AddNewLeaf()
   Dim s2l2 As TabGroupLeaf = s2.AddNewLeaf()
   Dim s2l3 As TabGroupLeaf = s2.AddNewLeaf()

   ' Add a tab page to each new leaf
   s1l1.TabPages.Add(New TabPage("Page1", new RichTextBox())
   s1l2.TabPages.Add(New TabPage("Page2", new RichTextBox())
   s2l1.TabPages.Add(New TabPage("Page3", new RichTextBox())
   s2l2.TabPages.Add(New TabPage("Page4", new RichTextBox())
   s2l3.TabPages.Add(New TabPage("Page5", new RichTextBox())

   ' Remove the single child leaf
   tabbedGroup.RootSequence.RemoveAt(0)

</pre>

			Note that we wait until the end before the leaf in the root sequence is removed. If it was removed before this point then the
			control would perform its usual processing and remove redundant leafs and sequences. It would also enforce the <i>AtLeastOneLeaf</i>
			property setting. So if we attempted to remove the root sequence leaf before all the new leafs had pages added then we would have 
			optimised away all the empty leafs and therefore empty sequences. Being empty it would have created a new leaf at the root sequence to
			honor the <i>AtLeastOneLeaf</i> property and the appearance would have been reduced back to a single empty leaf!<p /><h2>Spacing</h2>
			By default the new leafs we have added to the sequences will be spaced equally. We can however modify this relative spacing in order
			to achieve our aim of having the first two leafs spaced unevenly. Both the <i>TabGroupLeaf</i> and the <i>TabGroupSequence</i> have a 
			property called <i>Space</i> that specifies the percentage of free space that group should occupy. Each group also has a <i>MinimumSize</i> 
			property that is always provided no matter what the <i>Space</i> property indicates. So the calculation for sizing groups inside a sequence 
			takes two phases. First each group is given its requested minimum size and then in the second phase the remaining space is allocated to groups
			depending on the <i>Space</i> percentage of that remaining space. Therefore the total of all the <i>Space</i> values for children of a 
			sequence should always add up to exactly 100%.<p />

			The following code is added to the end of the previous code in order to space the leafs of the first sequence.<p /><code>C#</code><pre>
	
   // Allocate space that adds up to exactly 100%
   s1l1.Space = 66.666;
   s1l2.Space = 33.334;

   // Ask the control to reposition leafs using new spacing
   tabbedGroup.Reposition();

</pre><code>VB.NET</code><pre>

   ' Allocate space that adds up to exactly 100%
   s1l1.Space = 66.666
   s1l2.Space = 33.334

   ' Ask the control to reposition leafs using new spacing
   tabbedGroup.Reposition()

</pre>

		The last call is to the <i>Reposition()</i> method and asks the control to take into account the updated spacing values. This
		is not done automatically on setting the <i>Space</i> property because it is likely you will need to change several values at
		a time and we only want to layout the content once finished. It is important to note that setting a <i>Space</i> value on one
		group will not automatically update the others in the same sequence, therefore it is quite possible to make an error and find
		that the set of children no longer add up to 100%. This is deliberate and allows the programmer to update a set of values 
		without the control interferring in the process.<p /><h2>Rebalance</h2>
		You can use the <i>Rebalance()</i> method on the control to cause the spacing for all groups to be reset to a simple formula. It
		allocates each group an equal space within the sequence it resides. So if a sequence has two children then they are spaced to 
		50% each. If a sequence contains four children then they are set to 25% each. This method can be accessed by the user from the 
		context menu that is shown when right clicking a tab header at runtime. It can be very useful when the user has manipulated the
		layout and spacing and wants to quickly restore the view to something sensible.

		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="userinterface">User Interface</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <h2>DisplayTabsMode Property</h2>
			Use this property to define how the tab headers are to be handled in your control. Screen real estate is always precious
			and using the correct <i>DisplayTabsMode</i> can maximize its use and improve useability. The available options are as 
			follows: -

            <UL><LI><i>HideAll</i></LI><LI><i>ShowAll</i></LI><LI><i>ShowActiveLeaf</i></LI><LI><i>ShowMouseOver</i></LI><LI><i>ShowActiveAndMouseOver</i></LI><LI><i>ShowOnlyMultipleTabs</i></LI></UL><i>ShowAll</i> is the default and as the name implies will show all the tab headers for all the leaf groups.<p /><i>HideAll</i> is used to hide all the tab headers for all leaf groups in the control. This is useful in a couple of 
			different scenarios. Some applications may use the <i>TabbedGroups</i> control to create an organisation of groups and
			only present a single tab page in each of the leaf groups. In this case there is no need for tab headers because
			each group contains only a single page and the user is not required to move the pages around. Alternatively you might
			have multiple pages in each group but want to prevent the user from switching between them because it needs to be under
			programmatic control only.<p /><i>ShowActiveLeaf</i> will hide all the tab headers except for the leaf group that is active. You can use the <i>ActiveLeaf</i>
			property to discover which is the active leaf and also to change it to an alternative group. As the user moves focus to different
			leaf groups the tab header for the newly active group is shown and the tab header for the old group hidden.<p /><i>ShowMouseOver</i> only shows tab headers for a leaf group when the mouse is hovering over that group. As the mouse leaves
			the leaf group so the tab headers are hidden again.<p /><i>ShowActiveAndMouseOver</i> is a combination of both the <i>ShowActiveLeaf</i> and <i>ShowMouseOver</i> modes. If shows tab headers
			in the active leaf always and also any additional leaf group that has the mouser over it.<p /><i>ShowOnlyMultipleTabs</i> Will only show the tab headers when there is more than a single tab page in the tab control instance.<p /><h2>Color properties</h2>
			There are several properties used to customize the color appearance of the control. You can set the <i>ProminentBackColor</i>
			and <i>ProminentForeColor</i> values to modify how the tab header appears on the leaf group that is prominent. If you prefer
			the prominent leaf to be in the same colors as all other leaf groups then just clear the <i>ProminentColors</i> property that is set
			by default.<p />

			Define <i>ResizeBarColor</i> to alter the color of the resize bars that appear between groups. For an example of how to manipulate
			the colors see the supplied <i>SampleTabbedGroups</i> application.<p />

			If you are using the <i>VisualStyle.Office2003</i> appearance then you should make use of the three properties called 
			<i>OfficeStyleNormal</i>, <i>OfficeStyleSelected</i> and <i>OfficeStyleProminent</i>. These determine the color scheme used to draw
			the headers for each leaf in the normal, selected and prominent states respectively. All three properties use the <i>OfficeStyle</i>
			enumeration that has the following values: -
			
            <UL><LI><i>SoftWhite</i></LI><LI><i>LightWhite</i></LI><LI><i>DarkWhite</i></LI><LI><i>SoftEnhanced</i></LI><LI><i>LightEnhanced</i></LI><LI><i>DarkEnhanced</i></LI><LI><i>Light</i></LI><LI><i>Dark</i></LI></UL>

			It should be possible in most cases to use one of these predefined values that will cause the control to draw with colors relevant
			to the current desktop theme. In those situations where you need to customize the colors then you can rever to using the other
			color properties as described earlier.<p />

			The <i>VisualStyle.IDE2005</i> appearance has matching set of three properties called 
			<i>IDE2005Normal</i>, <i>IDE2005Selected</i> and <i>IDE2005Prominent</i>. These determine the color scheme used to draw
			the headers for each leaf in the normal, selected and prominent states respectively. All three properties use the <i>IDE2005Style</i>
			enumeration that has the following values: -
			
            <UL><LI><i>Standard</i></LI><LI><i>StandardDark</i></LI><LI><i>Enhanced</i></LI><LI><i>EnhancedDark</i></LI></UL><h2>ContextMenu Text</h2>
			There are a group of related properties that define the text to be used on the context menu that appears when you right click a tab page
			at runtime. These properties are provided so that non-english applications can alter the display text in an appropriate language. The 
			properties provided are:- <p /><UL><LI><i>CloseMenuText</i></LI><LI><i>ProminentMenuText</i></LI><LI><i>RebalanceMenuText</i></LI><LI><i>MovePreviousMenuText</i></LI><LI><i>MoveNextMenuText</i></LI><LI><i>NewVerticalMenuText</i></LI><LI><i>NewHorizontalMenuText</i></LI></UL><h2>Shortcut Definitions</h2>
			Many of the useful functions are available not just via the context menu but also by the use of keyboard combinations. You can modify these
			from the default values in cases where you want to disable the combination entirely or resolve a conflict with another use of the same 
			combination. A list of the properties and the default combinations follows:- <p /><UL><LI><i>CloseShortcut			= Ctrl+Shift+C</i></LI><LI><i>ProminentShortcut		= Ctrl+Shift+T</i></LI><LI><i>RebalanceShortcut		= Ctrl+Shift+R</i></LI><LI><i>MovePreviousShortcut		= Ctrl+Shift+P</i></LI><LI><i>MoveNextShortcut			= Ctrl+Shift+N</i></LI><LI><i>SplitVerticalShortcut	= Ctrl+Shift+V</i></LI><LI><i>SplitHorizontalShortcut	= Ctrl+Shift+H</i></LI></UL>

			If you need to disable all the shortcut keys and the ability to tab around the pages then it is easiest to clear the <i>IgnoreKeys</i> 
			property.

            <h2>FeedbackStyle</h2>
            Determines the visual feedback when dragging a content into a new position.
            
            The four possible values for the property are: -
            <UL><LI><i>DragFeedbackStyle.Outline</i></LI><LI><i>DragFeedbackStyle.Focus</i></LI><LI><i>DragFeedbackStyle.Squares</i></LI><LI><i>DragFeedbackStyle.Diamonds</i></LI></UL>

			The <i>Outline</i> style provides a focus rectangle outline appearance when
			the mouse is hovering over a potential drop position. A value of <i>Focus</i>
			provides a semi-transparent solid block of color when hovering over a potential
			drop position. When <i>Diamonds</i> are specified a set of helper icons are shown
			as the mouse is moved around to indicate the locations that a drop is allowed. 
			Placing the mouse over an icon will then show the drop effect if you release the
			mouse. The <i>Squares</i> style works in the same way but provides a different shape
			of icon that mimics the <i>VS.NET 2005</i> look and feel.<br />
            Default: <i>DragFeedbackStyle.Squares</i></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="persistence">Persistence</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			A set of methods are provided that allow the group hierarchy to be saved to a variety of different destinations.
			You can use the <i>SaveConfigToFile</i> method to save directly into a file, use the <i>SaveConfigToArray</i> to persist into
			an array of bytes (useful for saving into a database) or use the more generic <i>SaveConfigToStream</i>. This last method is
			a catch all method that allows any <i>Stream</i> instance to be provided for the destination making it possible for the developer
			to persist in any way required. There are a set of matching methods to perform loading called <i>LoadConfigFromArray</i>,
			<i>LoadConfigFromFile</i> and <i>LoadConfigFromStream</i>.<p /><h2>Providing extra global information</h2>
			If you need to store additional application specific information in the persistence information that you need to hook into the 
			<i>TabbedGroups.GlobalSaving</i> and <i>TabbedGroups.GlobalLoading</i> events. This allows extra XML information to be associated 
			with the saved/loaded stream.<p /><h2>Providing per page information</h2>
			You can also provide information on a per tab page level. Do this by hooking into the <i>TabbedGroups.PageSaving</i> and 
			<i>TabbedGroups.PageLoading</i> events. You could use this to save the name of the document the page represents or even the entire 
			document text. For example, if you were to use a simple <i>RichTextBox</i> per page in order to display a document you could save and 
			load the contents in the following way.<p /><code>C#</code><pre>

   private void HookEvents()
   {
      tabbedGroup.PageSaving += new PageSavingHandler(OnPageSaving);
      tabbedGroup.PageLoading += new PageLoadingHandler(OnPageLoading);
   }

   private void OnPageSaving(Crownwood.Magic.Controls.TabbedGroups tg, 
                             Crownwood.Magic.Controls.TGPageSavingEventArgs e)
   {
      e.XmlOut.WriteCData((e.TabPage.Control as RichTextBox).Text);
   }

   private void OnPageLoading(Crownwood.Magic.Controls.TabbedGroups tg, 
                              Crownwood.Magic.Controls.TGPageLoadingEventArgs e)
   {
      (e.TabPage.Control as RichTextBox).Text = e.XmlIn.ReadString();
   }
   
</pre><code>VB.NET</code><pre>

   Private Sub HookEvents()
      AddHandler tabbedGroup.PageSaving, AddressOf OnPageSaving
      AddHandler tabbedGroup.PageLoading, AddressOf OnPageLoading
   End Sub

   Private Sub OnPageSaving(ByVal tg As TabbedGroups, _
                            ByVal e As TGPageSavingEventArgs)
      e.XmlOut.WriteCData(CType(e.TabPage.Control, RichTextBox).Text)
   End Sub

   Private Sub OnPageLoading(ByVal tg As TabbedGroups, _
                             ByVal e As TGPageLoadingEventArgs)
      CType(e.TabPage.Control, RichTextBox).Text = e.XmlIn.ReadString()
   End Sub

</pre>		    

		Recreating the control that was inside the tab page can be done in one of two ways. By default the property <i>SaveControls</i>
		is set and will cause the type name of the control inside the tab page to be saved into the persisted data. At reload the type
		name will be read in and the control recreated and assigned to the recreated tab page. This allows the above code sample to work
		fully because the <i>OnPageSaving</i> saves the contents of the <i>RichTextBox</i>. When reloading the <i>RichTextBox</i> control
		is automatically recreated for the recreated tab page and so the <i>OnPageLoading</i> can easily set the loaded contents back into
		the <i>RichTextBox</i>.<p />
		
		You can choose to turn off the <i>SaveControls</i> property in which case it is the responsibility of the page loading event to 
		recreate the appropriate control and assign it to the recreated tab page. This might be more appropriate for complex applications
		where the choice of control to create is not fixed.
		    
		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="notifications">Notifications</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			There are several interesting events that can be generated by the 
			<I>TabbedGroups</I> which allow its operation to be monitored and modified.<p />

		    The events relating to persistence have already been described in the previous section and the events used for handling drag and 
			drop are descibed in the next section. Other events of particular interest are as follows.

			<h2>TabControlCreated event</h2>
			This is fired whenever a new <i>TabControl</i> is created for a <i>TabGroupLeaf</i> instance. Any associated event handlers will 
			be called with the control already setup with the appropriate default properties but you can modify these to customise the
		    appearance as needed. For example, you might alter the <i>TabControl.PositionAtTop</i> so that the tabs are always displayed
		    at the bottom of the group rather than defaulted to be at the top.<p /><h2>TabControlRemoved event</h2>
			Whenever an existing <i>TabControl</i> instance is removed from the control then this event is fired. This allows any actions,
			such as hooking into <i>TabControl</i> events, to be reversed. Otherwise the dangling event hook would prevent the control from
			being garbage collected at an appropriate time.<p /><h2>TabControlType event</h2>
      Just before a new <i>TabControl</i> is created this event is fired to ask if you would like to create different class instead
      of the default. Note that the type you specify must derive from <i>TabControl</i> itself but it does allow you the flexibility
      of adding additional behavior by creating a reusable class. This event is generated just before the <i>TabControlCreated</i>
      event listed above.<p /><h2>PageCloseRequest event</h2>
		    The <i>PageCloseRequest</i> event is fired in one of two ways. If the user presses the close button on the tab 
		    control itself then the event is fired, or if the close command from the context menu associated with a page is selected. Either 
		    way you have the chance to perform custom processing, such as asking the user if they need to save the document because it has 
		    changed since being opened. Note that you can cancel the request and not allow the page to be closed.<p /><h2>PageContextMenu event</h2>
		    Another crucial event is the <i>PageContextMenu</i> that is fired when the context menu for a tab page is about to be displayed.
		    This gives you the chance to add or remove commands from the <i>ContextMenuStrip</i> instance or even to cancel the menu entirely. Note that
		    the standard commands are always present in the menu commands collection and so it is safe to insert or remove entries by index value.
		    Any events removed will have been reinserted the next time the event is fired.<p /><h2>ActiveLeafChanged event</h2>
			Whenever the <i>ActiveLeaf</i> property changes this event is fired so that code can track which leaf group is active. It is possible
			for the <i>ActiveLeaf</i> to be defined as <i>null / Nothing</i> in some circumstances. Note that the active leaf does not change when
			the user switches between different pages in the same group.<p /><h2>PageChanged event</h2>
			Each time the user changes the active tab page this event will be fired. This allows the developer to track the tab page of interest to a user
			and perform any extra processing required. This will fire when switching between pages of the same group as well as when switching
			between pages that are present in different groups.<p /><h2>DirtyChanged event</h2>
			This event is used in conjunction with the <i>Dirty</i> property and shows when the structure of the group hierarchy has been modified.
			It is not fired when a change in active leaf occurs or when a change in page occurs. It is however fired when the user moves a page to a
			different group, creates or removes pages or changes the proportional spacing between groups.

		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="externaldrag">External Drag</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
			Many applications require the ability to drag from a source control and drop onto the <i>TabbedGroups</i> control. A typical 
			example is the use of a <i>TreeView</i> that lists available documents that the user should be able to drag onto an existing tab 
			group in order that the document is then opened and displayed. There are three ways you can enable this capability and the one
			used depends on how much flexibility you need.<p /><h2>DragProvider Class</h2>
			The source of the drag operation needs to instantiate an instance of the <i>DragProvider</i> class that exists in the namespace
			of the <i>TabbedGroups</i> control. You provide this new object in the call to the static <i>DoDragDrop</i> method. When the cursor 
			moves over the <i>TabbedGroups</i> control this format is recognised and the appropriate drop indicator drawn. When the drop occurs 
			the <i>ExternalDrop</i> event is generated passing this <i>DragProvider</i> instance as one of the parameters. This allows pertinent
			information to be passed from the source to the destination to allow the correct application specific actions to occur. As the
			information passed across is going to vary from application to application the <i>DragProvider</i> has just a single property 
			called <i>Tag</i> of type <i>object</i>. At its simplest you might box a string into the parameter, but you could create a new
			object instance and pass that instead.<p />
			
			An example of the client side code that starts the drag and drop operation is as follows: -<p /><code>C#</code><pre>

   // Create helper object recognised by the TabbedGroups control
   TabbedGroups.DragProvider dp = new TabbedGroups.DragProvider();

   // Box a fixed string to be passed across
   dp.Tag = (object)"Example fixed string";

   // Perform the drag and drop operation
   DoDragDrop(dp, DragDropEffects.Copy);

</pre><code>VB.NET</code><pre>

   ' Create helper object recognised by the TabbedGroups control
   Dim dp As New TabbedGroups.DragProvider()

   ' Box a fixed string to be passed across
   dp.Tag = CType("Example fixed string", object)

   ' Perform the drag and drop operation
   DoDragDrop(dp, DragDropEffects.Copy)

</pre>		 
	
		You need to hook into the <i>ExternalDrop</i> event for the <i>TabbedGroups</i> control and process the event 
		in the following manner. This example just creates a new page and places the provided string into a <i>RichTextBox</i>
		instance: -<p /><code>C#</code><pre>

   private void OnExternalDrop(
      Crownwood.DotNetMagic.Controls.TabbedGroups tg, 
      Crownwood.DotNetMagic.Controls.TabGroupLeaf tgl,
      Crownwood.DotNetMagic.Controls.TabControl tc,
      Crownwood.DotNetMagic.Controls.TabbedGroups.DragProvider dp)
   {
      // Create a new tab page
      Crownwood.DotNetMagic.Controls.TabPage tp = 
         new Crownwood.DotNetMagic.Controls.TabPage();

      // Define page properties
      tp.Text = "NewPage";
      tp.Control = new RichTextBox();

      // Define the text in this control
      (tp.Control as RichTextBox).Text = (string)dp.Tag;

      // We want the new page to become selected
      tp.Selected = true;

      // Add new page into the destination tab control
      tgl.TabPages.Add(tp);
}

</pre><code>VB.NET</code><pre>

   Private Sub ExternalDrop(
      ByVal tg As Crownwood.DotNetMagic.Controls.TabbedGroups, _
      ByVal tgl As Crownwood.DotNetMagic.Controls.TabGroupLeaf, _
      ByVal tc As Crownwood.DotNetMagic.Controls.TabControl, _
      ByVal dp As Crownwood.DotNetMagic.Controls.TabbedGroups.DragProvider) _
      Handles tabbedGroups.ExternalDrop

      ' Create a new tab page
      Dim tp As New Crownwood.DotNetMagic.Controls.TabPage

      ' Define page properties
      tp.Text = "NewPage"
      tp.Control = New RichTextBox()

      ' Define the text in this control
      CType(tp.Control, RichTextBox).Text = CType(dp.Tag, String)

      ' We want the new page to become selected
      tp.Selected = True

      ' Add new page into the destination tab control
      tgl.TabPages.Add(tp)
   End Sub

</pre>		 
   
		This is a quick an easy method but has a couple of drawbacks. First of all the the source has to be of 
		type <i>DragProvider</i> and there might be situations where that is not possible. Second is the fact you 
		cannot prevent the drop from occuring because any drag that has the source type of <i>DragProvider</i> will 
		be allowed to be dropped. You cannot be selective in deciding if the drop is allowed or to be rejected.<p /><h2>DropType property</h2>
		The first problem can be solved by setting the value of the <i>DropType</i> property to the <i>Type</i> that
		you would like to be allowed to be dropped. Whenever that type is found to be dragged over the tab headers then
		a drag and drop is allowed. When the drop occurs the event <i>ExternalDropType</i> is fired and will pass to the
		event handler the type instance that is being dropped.<p />

		You can only specify a single type to be allowed but you can operate this at the same time as the standard 
		<i>DragProvider</i> functionality. So depending on the type that is dropped will determine if the 
		<i>ExternalDrop</i> or <i>ExternalDropType</i> is called. This can be useful if you need to provide a rich set of
		source information for most situations (using <i>DragProvider</i>) but also want to allow some standard type to be 
		allowed as well (such as type <i>String</i> using <i>DropType</i>).<p /><h2>Dynamic events</h2>
		The third and most powerful technique allows fine controls over what is allowed to be dropped. You hook into the 
		two events called <i>ExternalDragEnter</i> and <i>ExternalDragOver</i> that return a <i>Boolean</i> result. If your
		event decides that the drag should be allowed then return <i>True</i> but if it should be rejected then return 
		<i>False</i>. Once the drop actually occurs the <i>ExternalDropRaw</i> will be called and provide the raw drop 
		information that can then be processed as appropriate.

		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
          </table></td>
      </tr>
    </table>
    <div style="position:absolute; left:20px; top:132px;">
      <a href="../readme.html" class="white">ReadMe</a>
      <span class="cyan">| </span>
      <a href="articles.html" class="white">Articles</a>
      <span class="cyan">| </span>
      <a href="contact.html" class="white">Contact</a>
    </div>
    <div style="position:absolute; left:620px; top:132px; text-align:right;">
      <span class="whitebold">Empowering the User</span>
    </div>
  </body>
</html>
