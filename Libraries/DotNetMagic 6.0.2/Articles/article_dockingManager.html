<html xmlns="http://www.w3.org/TR/REC-html40">
  <head>
    <title>Crownwood Software</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
    <meta name="resource-type" content="document" />
    <meta name="robots" content="ALL" />
    <meta name="copyright" content="Crownwood Software" />
    <meta name="author" content="Crownwood Software" />
    <meta name="description" content="Crownwood Software, DotNetMagic, Empowering the User" />
    <meta name="Content-Language" content="en-UK" />
    <meta name="Coverage" content="Worldwide" />
    <meta name="rating" content="general" />
    <link rel="stylesheet" type="text/css" href="./images/site.css" />
  </head>
  <body leftmargin="0" topmargin="0" border="0">
    <table border="0" cellpadding="0" cellspacing="0" width="775" style="background-repeat: no-repeat;">
      <tr>
        <td>
          <img src="./images/header-lhs.gif" /></td>
        <td>
          <img src="./images/header-mid.gif" /></td>
        <td>
          <img src="./images/header-rhs.gif" /></td>
      </tr>
    </table>
    <table width="775" height="100%" cellpadding="0" cellspacing="0" border="0">
      <tr>
        <td width="160" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td height="21">
                <img src="./images/shortcut-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/shortcut-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <span class="redheading">Index</span></td>
                  </tr>
                  <tr>
                    <td width="20"></td>
                    <td height="10"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#overview">overview</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#contents">contents</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#showandhide">show / hide</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#accurate">accurate</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#samewindow">same window</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#samecolumnrow">same column</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#innerouter">inner / outer</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#restrict">resticting users</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#persistence">persistence</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#factory">factory</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#methods">methods</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#properties">properties</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                  <tr>
                    <td height="15" width="20"></td>
                    <td height="15">
                      <a class="blue" href="#notifications">notifications</a></td>
                  </tr>
                  <tr>
                    <td height="2" width="20"></td>
                    <td height="2"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td height="20">
                <img src="./images/shortcut-bottom.gif" /></td>
            </tr>
          </table></td>
        <td width="615" valign="top">
          <table width="100%" cellpadding="0" cellspacing="0" border="0">
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="overview">DockingManager Overview</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
		    An instance of the <i>DockingManager</i> class needs to be created and
		    associated with each <i>ContainerControl</i> derived object you want to 
		    have a docking capability. Most of the time this will be your applications
		    top-level application <i>Form</i>. <p />
		    
			The following sections show how to use the control and describe the more important properties and 
			events for controlling the <i>DockingManager</i>. This is not however an exhaustive list and so the
			help document should be consulted for the definitive list of all functionality.<p />
		    
            As well as a <i>ContainerControl</i> reference the constructor takes
            a parameter indicating the visual style required. Currently six display 
            styles are supported, three of which are used to mimic the different color schemes 
            available with Office 2007. These are <i>VisualStyle.Office2007Blue</i>, <i>VisualStyle.Office2007Silver</i>
            and <i>VisualStyle.Office2007Black</i>. The <i>VisualStyle.Office2003</i> style mimics the look and
            feel of Office 2003 applications. Also available are <i>VisualStyle.IDE2005</i> for the VS.NET 2005 appearance and 
            <i>VisualStyle.IDE</i> for the VS.NET 2003 appearance.<p />
            The following code shows how to add docking support to a <i>Form</i>: -<br /><br /><code>C#</code><pre>
   
   using Crownwood.DotNetMagic.Common;
   using Crownwood.DotNetMagic.Docking;
   using Crownwood.DotNetMagic.Forms;

   public class MyForm : DotNetMagicForm
   {
      protected Crownwood.DotNetMagic.Docking.DockingManager 
         _dockingManager = null;

      public MyForm()
      {
         InitializeComponent();

         // If using toolstrips then attach to the content panel...
         _dockingManager = new DockingManager(toolStripContainer.ContentPanel, 
                                              VisualStyle.Office2007Blue);
      
         // If not using toolstrips then attach to the form itself
         _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);
      }
   }

</pre><code>VB.NET</code><pre>
   
   Imports Crownwood.DotNetMagic.Common
   Imports Crownwood.DotNetMagic.Docking
   Imports Crownwood.DotNetMagic.Forms

   Public Class MyForm
      Inherits DotNetMagicForm

      Protected _dockingManager As 
         Crownwood.DotNetMagic.Docking.DockingManager

      Public Sub New()
         InitializeComponent()

         ' If using toolstrips then attach to the content panel...
         _dockingManager = New DockingManager(toolStripContainer.ContentPanel, 
                                              VisualStyle.Office2007Blue)
      
         ' If not using toolstrips then attach to the form itself
         _dockingManager = New DockingManager(Me, VisualStyle.Office2007Blue)
      
      End Sub
   End Class

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="contents">Contents</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            Now we need to provide the docking manager with descriptions of 
            each dockable unit. This is the purpose of the <i>Content</i> class. 
            Each <i>Content</i> object creates an association between a title, 
            image and <i>Control</i> derived object. You should read the full 
            documentation of this important class before continuing, use this 
            <a class="mainLink" href="article_content.html">Content class link</a>.<p />
            The following code shows how to create a <i>Content</i> instance and 
            add it to the docking manager inside the form constructor. It creates 
            a <i>RichTextBox</i> control that will act as a dockable notepad for 
            use by the user.<br /><br /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad = new Content(_dockingManager);
   
      notePad.Title = "Notepad";
      notePad.Control = new RichTextBox();
      notePad.ImageList = _internalImages;
      notePad.ImageIndex = _imageIndex;

      _dockingManager.Contents.Add(notePad);
   }
   
</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      _dockingManager = New DockingManager(Me, VisualStyle.Office2007Blue)

      Dim notePad As New Content(_dockingManager)
   
      notePad.Title = "Notepad"
      notePad.Control = new RichTextBox()
      notePad.ImageList = _internalImages
      notePad.ImageIndex = _imageIndex

      _dockingManager.Contents.Add(notePad)
   End Sub
   
</pre>
            As this is such a common operation the process has been streamlined. 
            There are several overrides of the <i>Contents.Add</i> method that 
            will create the required <i>Content</i> instance for you during the 
            <i>Add</i> process. Here is the recommended approach: -<br /><br /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      ' This will create and add a new Content object all in one operation
      _dockingManager.Contents.Add(new RichTextBox(), "Notepad", 
                                   _internalImages, _imageIndex);
   }

</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      Dim _dockingManager As New DockingManager(Me, VisualStyle.Office2007Blue)

      ' This will create and add a new Content object all in one operation
      _dockingManager.Contents.Add(New RichTextBox(), "Notepad", _
                                   _internalImages, _imageIndex)
   End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="showandhide">Showing and Hiding Contents</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            Just adding a <i>Content</i> instance will not make it visible to the 
            user. We want our application to make this instance visible immediately, 
            so we use the <i>ShowContent</i> method as shown below: -<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      _dockingManager.Contents.Add(new RichTextBox(),
                                   "Notepad", 
                                   _internalImages, 
                                   _imageIndex);

      // Make the content with title 'Notepad' visible
      _dockingManager.ShowContent(_dockingManager.Contents("Notepad"));
   }

</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue)

      _dockingManager.Contents.Add(new RichTextBox(), _
                                   "Notepad", _
                                   _internalImages, _
                                   _imageIndex)

      ' Make the content with title 'Notepad' visible
      _dockingManager.ShowContent(_dockingManager.Contents("Notepad"))
   End SUb

</pre>
            This shows how to find a reference to a <i>Content</i> object by using 
            the string indexer of the <i>Contents</i> collection. In this particular 
            case it is a little inefficient as we could have stored the <i>Content</i>
            reference that is returned from the call to <i>Contents.Add</i>. Here is a 
            more efficient example: -<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad", _internalImages, _imageIndex);

      _dockingManager.ShowContent(notePad);
   }

</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue);

      Dim notePad As Content = _dockingManager.Contents.Add( _
        New RichTextBox(), "Notepad", _internalImages, _imageIndex)

      _dockingManager.ShowContent(notePad)
   End Sub

</pre>
            At some point in the future you may want to hide this instance again in which 
            case you can use the <i>HideContent</i> method. To make all the <i>Content</i> 
            instances visible or invisible use the <i>ShowAllContent</i> and <i>HideAllContent</i> 
            methods respectively.
		</content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="accurate">Accurate creation</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            Three lines of code and we have a docking window made visible to the user which 
            can be redocked and resized. However, at no point so far have we specified exactly 
            where the new <i>Content</i> gets shown. The docking position for a <i>Content</i> 
            made visible is the saved position from when it was last hidden. In our case the 
            instance has never been hidden because it has just been created.<p />
            The constructor for the <i>Content</i> will default the saved docking position to 
            be the left edge. Therefore our last example above will display the content inside 
            a docking window which is docked against the left edge of the application <i>Form</i>. 
            The value of the <i>Content.DisplaySize</i> will be used to decide how wide the 
            docking window should be, this defaults to <i>150, 150</i>.<p />
            If you want to dock against a different edge or even begin in the floating state 
            then you need to do a little more work. The following code shows the use of the 
            <i>AddContentWithState</i> method to show the content with a defined initial state: -<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent()

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad", _internalImages, _imageIndex);

      // Request new Docking window be created and displayed on the right edge
      _dockingManager.AddContentWithState(notePad, State.DockRight);
   }

</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue)

      Dim notePad As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad", _internalImages, _imageIndex)

      ' Request new Docking window be created and displayed on the right edge
      _dockingManager.AddContentWithState(notePad, State.DockRight)
   End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="samewindow">Create in same window</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            Using the above method allows a docking window to be made visible and its position 
            defined. But it does have the drawback that it will always create a new docking 
            window to host the <i>Content</i> instance. What if we want two or more <i>Content</i>
             objects to be hosted inside the same docking window? To achieve this we need to bring 
            another method called <i>AddContentToWindowContent</i> into use.<p />
            Each content is always hosted inside a <i>WindowContent</i> derived object. We can 
            remember the reference of the newly created <i>WindowContent</i> object and reuse it 
            as the destination for other <i>Content</i> instances. The following example creates 
            <i>notePad</i> instances that are placed inside the same docking window, when this happens 
            the docking window will adopt a tabbed appearance: -<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad1 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex);

      Content notePad2 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex);

      WindowContent wc = _dockingManager.AddContentWithState(
                            notePad1, State.DockRight) as WindowContent;

      // Add the second notePad2 to the same WindowContent
      _dockingManager.AddContentToWindowContent(notePad2, wc);
   }

</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue)

      Dim notePad1 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex)

      Dim notePad2 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex)

      Dim wc As WindowContent = _dockingManager.AddContentWithState( _
        notePad1, State.DockRight) as WindowContent

      ' Add the second notePad2 to the same WindowContent
      _dockingManager.AddContentToWindowContent(notePad2, wc)
   End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="samecolumnrow">Create in same Column/Row</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            There is only one more ability we need to add so that any docking configuration 
            can be constructed at start-up. We need the ability to place docking windows in 
            the same column or row. To do this we have to understand more about the actual 
            structure of objects maintained by the docking code.<p />
            Docking is supported by providing three levels of object. Each <i>Content</i> 
            object exists inside a <i>Window</i> derived object which itself exists inside a 
            <i>Zone</i> derived object. The <i>WindowContent</i> class is a specialization 
            of the <i>Window</i> base class that has special knowledge about how to handle 
            <i>Content</i> objects. It is easiest to explain by providing some examples.<p />
            The <i>AddContentWithState</i> method creates a new <i>WindowContent</i> instance 
            and adds to it the provided <i>Content</i> parameter. Next a <i>Zone</i> is created 
            and the <i>WindowContent</i> instance placed inside it. The <i>Zone</i> is then added
            to the hosting <i>Form</i> and positioned according to the <i> State</i> 
            parameter.<p />
            The <i>AddContentToWindowContent</i> adds the provided <i>Content</i> parameter to the 
            existing <i>WindowContent</i> instance.<p /> 
            The <i>AddContentToZone</i> method creates a new <i>WindowContent</i> instance and 
            adds to it the provided <i>Content</i> parameter. It then  adds the new 
            <i>WindowContent</i> to the provided <i>Zone</i> in the correct relative position.<p />
            The following example shows how to create three <i>notePad</i> objects, where the first two 
            are added to the same <i>WindowContent</i> causing a tabbed appearance to occur. The 
            final <i>notePad</i> is created in its own <i>WindowContent</i> and then added to the same 
            <i>Zone</i>. The position value of <i>0</i> will make the second <i>WindowContent</i> 
            be positioned first in the <i>Zone</i>.<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad1 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex);

      Content notePad2 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex);

      Content notePad3 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad3", _internalImages, _imageIndex);

      WindowContent wc = _dockingManager.AddContentWithState(
                            notePad1, State.DockRight) as WindowContent;

      _dockingManager.AddContentToWindowContent(notePad2, wc);

      // Add a new WindowContent to the existing Zone already created
      _dockingManager.AddContentToZone(notePad3, wc.ParentZone, 0);
   }

</pre><code>VB.NET</code><pre>

   Public Sub New
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue)

      Dim notePad1 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex)

      Dim notePad2 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex)

      Dim notePad3 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad3", _internalImages, _imageIndex)

      Dim wc As WindowContent = _dockingManager.AddContentWithState( _
        notePad1, State.DockRight) as WindowContent

      _dockingManager.AddContentToWindowContent(notePad2, wc)

      ' Add a new WindowContent to the existing Zone already created
      _dockingManager.AddContentToZone(notePad3, wc.ParentZone, 0)
   End Sub

</pre>
            You can use the <i>Content.ParentWindowContent</i> property to discover 
            which <i>WindowContent</i> a <i>Content</i> instance is currently placed 
            inside. Likewise, the <i>WindowContent.ParentZone</i> property indicates 
            the <i>Zone</i> a <i>WindowContent</i> instance is inside. Using these and 
            the above-described methods should allow any start up configuration to be 
            constructed. Note that the <i>Content.ParentWindowContent</i> property returns 
            <i>null</i> if the <i>Content</i> is not currently visible.<p /><h2>Setting the Relative Size</h2><p />
            By default each <i>Content</i> instances will be given an equal amount
            of space in the column of the <i>Zone</i>. So with three instances you will find each 
            one is given 1/3 of the available height. If this is not appropriate for your application 
            then you can alter the relative spacing once they have all been added to the <i>Zone</i>.<p />
            To do this you just alter the <i>ZoneArea</i> property of each <i>Content</i> making
            sure that the total always comes to 100 as the values represent percentages. Then you
            call the <i>RelayoutContents</i> method on the <i>Zone</i> so that the new <i>ZoneArea</i>
            values are used to update the display. The following shows the first notepad taking up 
            50 percent of the space and the other two notepads taking up 25 percent each.<p /><code>C#</code><pre>

   public MyForm()
   {
      InitializeComponent();

      _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

      Content notePad1 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex);

      Content notePad2 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex);

      Content notePad3 = _dockingManager.Contents.Add(
        new RichTextBox(), "Notepad3", _internalImages, _imageIndex);

      WindowContent wc1 = _dockingManager.AddContentWithState(
                            notePad1, State.DockRight) as WindowContent;

      WindowContent wc2 = __dockingManager.AddContentToZone(
                            notePad2, wc1.ParentZone, 1) as WindowContent;

      WindowContent wc3 = _dockingManager.AddContentToZone(
                            notePad3, wc1.ParentZone, 2) as WindowContent;

      // Define the new relative spacing as percentages
      wc1.ZoneArea = 50;
      wc2.ZoneArea = 25;
      wc3.ZoneArea = 25;
      
      // Force Zone to reposition Content using new percentages
      wc1.ParentZone.RelayoutContents();
   }

</pre><code>VB.NET</code><pre>

   Public Sub New
      InitializeComponent()

      Dim _dockingManager As New DockingManager(this, VisualStyle.Office2007Blue)

      Dim notePad1 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad1", _internalImages, _imageIndex)

      Dim notePad2 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad2", _internalImages, _imageIndex)

      Dim notePad3 As Content = _dockingManager.Contents.Add( _
        new RichTextBox(), "Notepad3", _internalImages, _imageIndex)

      Dim wc1 As WindowContent = _dockingManager.AddContentWithState( _
        notePad1, State.DockRight) as WindowContent

      Dim wc2 As WindowContent = _dockingManager.AddContentToZone( _
        notePad2, wc1.ParentZone, 1) as WindowContent

      Dim wc3 As WindowContent = _dockingManager.AddContentToZone( _
        notePad3, wc1.ParentZone, 2) as WindowContent

      ' Define the new relative spacing as percentages
      wc1.ZoneArea = 50
      wc2.ZoneArea = 25
      wc3.ZoneArea = 25
      
      ' Force Zone to reposition Content using new percentages
      wc1.ParentZone.RelayoutContents()
   End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="innerouter">Control where docking can occur</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            The <i>OuterControl</i> and <i>InnerControl</i> properties are used to define
            the limits for the positioning of docking windows when they are moved at runtime 
            by the user. For example, imagine you have an application that has a <i>MenuStrip</i>
            and <i>StatusBarStrip</i> docked against the top and bottom edges respectively. When 
            the user moves a docking window at runtime we do not want them to be allowed to 
            place the docking window above the <i>MenuStrip</i> or below the <i>StatusBarStrip</i> 
            controls. In order to achieve this effect we need to define the <i>OuterControl</i> 
            property.<p />
            
            The <i>OuterControl</i> property needs to be set to the first control in 
            the <i>Forms.Control</i> collection that represents the group of controls 
            that the manager must not dock between. Remember that the order of controls in 
            the <i>Form.Control</i> collection determines the sizing and positioning of them. 
            So the last control in the collection is the one that is positioned and sized 
            first, the second to last control will be positioned and sized in the space that 
            remains.<p />
      
            As the <i>MenuStrip</i> is the most important and needs to be positioned first 
            it will be last in the collection. The <i>StatusBarStrip</i> is the next most important 
            and so is second to last in the collection. In this scenario the <i>OuterControl</i> 
            would be set to a reference of the <i>StatusBarStrip</i> control. This will prevent the 
            docking manager from reordering any window after the <i>StatusBarStrip</i> in the 
            collection. If the <i>StatusBarStrip</i> was last in the list and the <i>MenuStrip</i> 
            second to last then the <i>OuterControl</i> would need to reference the 
            <i>MenuControl</i> instead.<p />
      
            The <i>InnerControl</i> property needs to be set to the last control in the 
            <i>Forms.Control</i> collection that represents the group of controls that the 
            manager must not dock after. This might seem odd, as there is unlikely to be a 
            docked window you would not want the docking windows to be placed inside of. However 
            there is a situation where this becomes important.<p />
      
            If you have a control that is defined as having the <i>Dock</i> property of 
            <i>DockStyle.Fill</i> then this control must always occur in the <i>Form.Control</i>
            collection before any docking windows. Otherwise you can get the situation where the 
            control with the <i>DockStyle.Fill</i> value is not sized according to the actual 
            space left over when all docking windows have been placed. Because this control is 
            further up the list of controls it calculates its size without taking into account 
            any docking windows that occur earlier in the collection.<p />
      
            The following shows a <i>MenuStrip</i>, <i>StatusBarStrip</i> and a <i>RichTextBox</i> 
            being created and added to the <i>Form.Control</i> collection. It then sets the 
            correct <i>InnerControl</i> and <i>OuterControl</i> values to generate the expected 
            runtime operation.<br /><br /><code>C#</code><pre>

  public MyFormConstructor()
  {
  RichTextBox filler = new RichTextBox();
  filler.Dock = DockStyle.Fill;
  Controls.Add(filler);

  StatusBarStrip status = new StatusBarStrip();
  status.Dock = DockStyle.Bottom;
  Controls.Add(status);

  MenuStrip menu = new MenuStrip();
  menu.Dock = DockStyle.Top;
  Controls.Add(menu);

  _dockingManager = new DockingManager(this, VisualStyle.Office2007Blue);

  _dockingManager.InnerControl = filler;
  _dockingManager.OuterControl = status;

  // Now create and setup my Content objects
  ...
  }

</pre><code>VB.NET</code><pre>

  Public Sub New()
  Dim filler As New RichTextBox()
  filler.Dock = DockStyle.Fill
  Controls.Add(filler)

  Dim status As New StatusBarStrip()
  status.Dock = DockStyle.Bottom
  Controls.Add(status)

  Dim menu As New MenuStrip()
  menu.Dock = DockStyle.Top
  Controls.Add(menu)

  _dockingManager = New DockingManager(Me, VisualStyle.Office2007Blue)

  _dockingManager.InnerControl = filler
  _dockingManager.OuterControl = status

  ' Now create and setup my Content objects
  ...
  End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="restrict">Restricting user activity</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
      Most applications will create a set of docking windows and then allow the user free reign
      over moving and changing the layout. Indeed, this is the main reason for using docking
      windows in the first place. Giving the user this flexibility can be a major selling point for
      an application, but not all applications want to give the user such unrestricted control.
      There are three properties of the <i>DockingManager</i> that can be used to restrict the
      actions a user can make at runtime.<p /><b>AllowFloating</b><br />
      By default this property has a value of <i>True</i> and so allows the user to change the state
      of a docking window from being docked to floating and vica versa. By setting the value to <i>False</i>
      you prevent the creation of any floating windows. The user will not be able to drag a docked or
      double click a title bar in order to convert it into a floating window. They can however still drag a
      docked window from one edge to a different edge. You cannot even programmatically create floating
      windows.<p /><b>AllowRedocking</b><br />
      This is much more restrictive and prevents the user from performing any runtime redocking at all. The
      user cannot double click or drag any content at all and so cannot change the docking state. They can however use
      the context menu to show or hide a <i>Content</i> and they can move a floating window to a new screen position.
      There are no restrictions on changing the layout programmatically. By default this property is defined as <i>True</i>.

      <b>AllowTabbed</b><br />
      By default the user can drag and drop content to reposition them and this includes the ability to drop a content
      inside another content to created a tabbed appearance. If you set this property to <i>False</i> then the user is
      prevented from dropping content inside other content to created this tabbed functionality. It does not however
      prevent programmatic code from being able to created tabbed content or prevent loading configurations from also
      creating tabbed appearance.

      <b>AllowResize</b><br />
      By default the user can resize floating forms and resize any of the docked content. If you want to prevent
      this then set the property to <i>false</i> instead. In that case floating forms are no longer sizable and the
      user cannot change the width/height of content docked againt form edges.<p /></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="persistence">Persistence</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
            Many applications need to be able to remember several different docking 
            configurations of the <i>Content</i> objects and be able to switch between 
            them at runtime. You might also want to save the configuration when the 
            application is shutdown so that it can be restored at start-up. The code to 
            save and load configurations is as follows:-<p /><code>C#</code><pre>

   // Save the current configuration to a named file   
   _dockingManager.SaveConfigToFile("MyFileName.xml");

   ...

   // Load a saved configuration and apply immediately
   _dockingManager.LoadConfigFromFile("MyFileName.xml");

</pre><code>VB.NET</code><pre>

   ' Save the current configuration to a named file   
   _dockingManager.SaveConfigToFile("MyFileName.xml")

   ...

   ' Load a saved configuration and apply immediately
   _dockingManager.LoadConfigFromFile("MyFileName.xml")

</pre>

            There are a couple of issues to remember though. The saving process does 
            not save the actual <i>Content</i> objects but just the state information 
            it needs in order to restore that <i>Content</i> to the same docking 
            size/position later. So the <i>Content</i> object must already exist and be 
            part of the docking manager when the load operation takes place because 
            loading will not recreate those objects.<p />
            The second point is that the save and load use the <i>Title</i> property of 
            the <i>Content</i> to identify the information. If you change the <i>Title</i> 
            of a <i>Content</i> object between saving and loading then the latter process 
            will fail to associate the saved information to the object. This will not 
            cause an exception but that <i>Content</i> will not be updated with the 
            required configuration.<p />
            You can avoid this problem if you assign unique values to the <i>UniqueName</i>
            property of each <i>Content</i> instance. This then allows you to use different
            title string depending on the appropriate language of the user. Note that you should
            either assign unique values to all the content instances or to none of them.<p />
            If you need to save the configuration information into a database or simply 
            save it internally then you do not have to save into a file. There are 
            matching methods for saving and loading into byte arrays which are easy to 
            store within your application or to a database. For even greater control use 
            the methods that take a stream object instance, in which case you must create 
            and provide the stream object instance, but this gives the developer complete 
            control over the storage medium.<p />
            Some developers might find it useful to save and load some additional custom 
            details inside the configuration data. This prevents the need for two sets of saved
            data which then need to be maintained in parallel. The <i>SaveCustomConfig</i> 
            event is generated when all the docking information has been written and allows
            you to add additional information at the end. <p />
            On loading the <i>LoadCustomConfig</i> event is generated so that the corresponding 
            information can be read back in again. The following sample code shows a trivial example 
            of this:-<p /><code>C#</code><pre>

   public MyFormConstructor()
   {
      InitializeComponent();
      
      // Setup custom config handling at appropriate place in code
      _manager.SaveCustomConfig += 
         new DockingManager.SaveCustomConfigHandler(OnSaveConfig);
         
      _manager.LoadCustomConfig += 
         new DockingManager.LoadCustomConfigHandler(OnLoadConfig);
   }
   
   protected void OnSaveConfig(XmlTextWriter xmlOut)
   { 
      // Add an extra node into the config to store some example information
      xmlOut.WriteStartElement("MyCustomElement");
      xmlOut.WriteAttributeString("ExampleData1", "Hello");
      xmlOut.WriteAttributeString("ExampleData2", "World!");
      xmlOut.WriteEndElement();
   }

   protected void OnLoadConfig(XmlTextReader xmlIn)
   {
      // We are expecting our custom element to be the current one
      if (xmlIn.Name == "MyCustomElement")
      {
         // Read in both the expected attributes
         string attr1 = xmlIn.GetAttribute(0);
         string attr2 = xmlIn.GetAttribute(1);

         // attr1 should contain Hello
         // attr2 should contain World!

         // Must move past our element
         xmlIn.Read();
      }
   }
   
</pre><code>VB.NET</code><pre>

   Public Sub New()
      InitializeComponent()

      ...
      
      // Setup custom config handling at appropriate place in code
      AddHandler _manager.SaveCustomConfig, AddressOf OnSaveConfig
      AddHandler _manager.LoadCustomConfig, AddressOf OnLoadConfig
   End Sub
   
   Protected Sub OnSaveConfig(Dim xmlOut As XmlTextWriter)
      ' Add an extra node into the config to store some example information
      xmlOut.WriteStartElement("MyCustomElement")
      xmlOut.WriteAttributeString("ExampleData1", "Hello")
      xmlOut.WriteAttributeString("ExampleData2", "World!")
      xmlOut.WriteEndElement()
   End Sub

   Protected Sub OnLoadConfig(Dim xmlIn As XmlTextReader)
      ' We are expecting our custom element to be the current one
      If (xmlIn.Name = "MyCustomElement") Then
         ' Read in both the expected attributes
         Dim attr1 As String = xmlIn.GetAttribute(0)
         Dim attr2 As String = xmlIn.GetAttribute(1)

         ' attr1 should contain Hello
         ' attr2 should contain World!
		 
         ' Must move past our element
         xmlIn.Read()
      End If
   End Sub

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="factory">Docking Factory</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
      In some circumstances you might want to customise the existing control and 
      form classes that make up the docking windows system. You could do this by
      modifying the source code directly and then performing a build of the code.
      Although this will certainly work it does require that you reapply the
      changes each time a new release of the library is made.<p />
      
      An alternative that will work in the majority of cases is to derive new classes
      from the existing ones that add the extra functionality. However, many of the
      class instances are created at runtime on demand. To ensure your custom classes
      are created you need to derive from the default <i>DockingFactory</i> class.<p />
      
      The <i>DockingFactory</i> has a set of virtual methods that are called whenever a
      new control or form of a particular type is needed. In your derived implementation
      you can ensure your own derived class is instantiated instead of the default internal
      class. You then create an instance of your <i>DockingFactory</i> derived class and pass
      it in as a parameter of the <i>DockingManager</i> constructor.<p />

      This is best illustrated with an example:-<p /><code>C#</code><pre>
   
   public CustomContentTabbed : WindowContentTabbed
   {
      // Customized version of the docking class
   }
   
   public CustomFactory : DockingFactory
   {
      public override WindowContentTabbed 
            CreateWindowContentTabbed(DockingManager manager, 
                                      VisualStyle vs)
      {
         // Create our derived version of the control
         return new CustomContentTabbed(manager, vs);
      }
   }
        
   public MyFormConstructor()
   {
      // Creat custom version of the docking factory
      DockingFactory df = new CustomFactory();
   
      _dockingManager = new DockingManager(this,
                                           VisualStyle.Office2003,
                                           factory);
   }

      </pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="methods">Methods</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <b>ShowAllContents()</b>
                              <br />
            Make all hidden <i>Content</i> objects visible.<p /><b>HideAllContents()</b><br />
            Make all visible <i>Content</i> objects hidden.<p /><b>ShowContent(Content c)</b><br />
            If the provided object is hidden then it will be restored to become visible.<p /><b>HideContent(Content c)</b><br />
            If the provided object is visible then it will become hidden.<p /><b>HideContent(Content c, bool record, bool reorder)</b><br />
            Provides greater control over actions taken when a <i>Content</i> becomes hidden.<br /> 
            This is provided for internal use by the docking windows framework code.<br />
            If <i>record</i> is set then it will record the current <i>Content</i> 
            position before hiding window.<br />
            If <i>reorder</i> is set then it will move the <i>Content</i> to the 
            end of the <i>Contents</i> collection.<p /><b>CreateWindowForContent(Content c)</b><br />
            Used to create an appropriately configured <i>Window</i> object for 
            the given <i>Content</i> object.<br /> Currently this ensures the caption 
            bar matches the requested style specified in the constructor.<p /><b>CreateZoneForContent(State zoneState)</b><br />
            Creates an appropriate <i>Zone</i> object and adds it to the managed control.<p /><b>AddContentWithState(Content c, State newState)</b><br />
            Will create an appropriate <i>Window</i> for hosting the provided 
            <i>Content</i> and place inside a new <i>Zone</i> which is placed 
            according to the <i>State</i> given.<p /><b>AddContentToWindowContent(Content c, WindowContent wc)</b><br />
            If you already have a reference to a <i>WindowContent</i> object then 
            this method will add the provided 
            <i>Content</i> into that object.<p /><b>AddContentToZone(Content c, Zone z, int index)</b><br />
            If you already have a reference to a <i>Zone</i> object then this will 
            create a new <i>Window</i> to host the provided <i>Content</i> and then 
            add the <i>Window</i> to the given relative position inside the <i>Zone</i>.<p /><b>ReorderZoneToInnerMost(Zone zone)</b><br />
            Repositions the given reference within the list of <i>Form</i> controls 
            to the innermost valid point.<p /><b>ReorderZoneToOuterMost(Zone zone)</b><br />
            Repositions the given reference within the list of <i>Form</i> controls 
            to the outermost valid point.<p /><b>SaveConfigToArray()</b><br />
            Saves layout information into an array of bytes using Encoding.Unicode.<p /><b>SaveConfigToArray(Encoding encoding)</b><br />
            Saves layout information into an array of bytes using caller provided 
            encoding object.<P /><b>SaveConfigToFile(string filename)</b><br />
            Saves layout information into a named file using Encoding.Unicode<p /><b>SaveConfigToFile(string filename, Encoding encoding)</b><br />
            Saves layout information into a named file using caller provided encoding 
            object.<p /><b>SaveConfigToStream(Stream stream)</b><br />
            Saves layout information into a stream object Encoding.Unicode.<p /><b>SaveConfigToStream(Stream stream, Encoding encoding)</b><br />
            Saves layout information into a stream object using caller provided. 
            <p /><b>LoadConfigFromArray(byte[] buffer)</b><br />
            Loads layout information from given array of bytes.<p /><b>LoadConfigFromFile(string filename)</b><br />
            Loads layout information from given filename.<p /><b>LoadConfigFromStream(Stream stream)</b><br />
            Loads layout information from given stream object.<p /><b>ResetColors()</b><br />
            Use this to reset all colors to the defaults used when the docking 
            manager is first created.<p /><b>RemoveShowingAutoHideWindows()</b><br />
            If any of the AutoHide windows is currently being shown then this will 
            remove it from display immediately.<p /><b>BringAutoHideIntoView(Content c)</b><br />
            If the given content instance is in the AutoHide mode then it will be 
            selected and will slide out into view.<p /><b>OnShowContextMenu(ContentCollection cc, Point screenPos)</b><br />
            Use this method to initiate the docking context menu at given screen location. The content collection
	          parameter gives you the set of <i>Content</i> instances related to the context menu. So if the user right clicked a
            floating form then it will contain all the <i>Content</i> instances inside the form. If the user right clicked a docking
            window caption then it will contain all the <i>Content</i> instances inside that tabbed window.<p /></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="properties">Properties</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <b>Container</b>
                              <br />
            The object to which the docking manager instance is attached.<br />
            Default: <i>null</i><p /><b>Contents</b><br />
            The collection of <i>Content</i> objects that the manager is responsible 
            for docking.<p /><b>InnerControl</b><br />
            Docking windows will not be allowed to dock inside of the specified 
            control.<br />
            Default: <i>null</i><p /><b>OuterControl</b><br />
            Docking windows will not be allowed to dock outside of the specified 
            control.<br />
            Default: <i>null</i><p /><b>ShowUnmatchedOnLoad</b><br />
            When you load configuration settings the docking has to decide what to do for content instances
            that are defined but not present in the config settings. By default this property is <i>false</i>
            and this causes unmatched content to be hidden. If you want unmatched content to always be shown
            then set this to <i>true</i> instead.<br />
            Default: <i>false</i><p /><b>ZoneMinMax</b><br />
            If more than one <i>Window</i> is docked in the same column/row should 
            they have a maximize capability.<br />
            Default: <i>true</i><p /><b>InsideFill</b><br />
            When defined the innermost docking window will assume the <i>Fill</i> 
            docking style so that you can create applications whose client area 
            consists only of docking windows.<br />
            Default: <i>false</i><p /><b>AutoResize</b><br />
            When defined a resizing of the control will cause the docking windows 
            to be resized smaller if they would start overlapping. Note that the windows
            will not be sized bigger again when the control is increased in size.<br />
            Default: <i>true</i><p /><b>InnerMinimum</b><br />
            Defines the minimum size of the inner control, if resizing the application 
            would cause the inner control to become smaller than this then the docking 
            windows are resized smaller instead.<br />
            Default: <i>Size(20, 20)</i><p /><b>Style</b><br />
            Defines the visual style used for display.<p /><b>StubsShowAll</b><br />
            When a group of tabbed contents are placed into the auto hidden mode they
            show as a tab stub against one of the docking edges. When this property is
            defined as <i>false</i> then only the selected tab in the stub has text as
            well as the image displayed. If defined as <i>true</i> then all the tabs in
            stub have the text and image shown.<br />
            Default: <i>True for VisualStyle.IDE2005; otherwise false.</i><p /><b>FeedbackStyle</b><br />
            Determines the visual feedback when dragging a content into a new docking
            position.
            
            The four possible values for the property are: -
            <UL><LI><i>DragFeedbackStyle.Outline</i></LI><LI><i>DragFeedbackStyle.Focus</i></LI><LI><i>DragFeedbackStyle.Squares</i></LI><LI><i>DragFeedbackStyle.Diamonds</i></LI></UL>

			The <i>Outline</i> style provides a focus rectangle outline appearance when
			the mouse is hovering over a potential drop position. A value of <i>Focus</i>
			provides a semi-transparent solid block of color when hovering over a potential
			drop position. When <i>Diamonds</i> are specified a set of helper icons are shown
			as the mouse is moved around to indicate the locations that a drop is allowed. 
			Placing the mouse over an icon will then show the drop effect if you release the
			mouse. The <i>Squares</i> style works in the same way but provides a different shape
			of icon that mimics the <i>VS.NET 2005</i> look and feel.<br />
            Default: <i>DragFeedbackStyle.Squares</i><p /><b>ResizeBarVector</b><br />
            Defines the width/height of resize bars used between docking windows. A value 
            of -1 will cause the appropriate default value for the selected style to be 
            used instead.<br />
            Default: <i>-1</i><p /><b>BackColor</b><br />
            Background drawing color used in the caption bar when the docking window is 
            not selected.<br />
            Default: <i>SystemColors.Control</i><p /><b>ActiveColor</b><br />
            Background drawing color used in the caption bar when the docking window is 
            selected.<br />
            Default: <i>SystemColors.ActiveCaption</i><p /><b>ActiveTextColor</b><br />
            Text drawing color used in the caption bar when the docking window is 
            selected.<br />
            Default: <i>SystemColors.ActiveCaptionText</i><p /><b>InactiveTextColor</b><br />
            Text drawing color used in the caption bar when the docking window is not 
            selected.<br />
            Default: <i>SystemColors.ControlText</i><p /><b>ResizeBarColor</b><br />
            Background color used to draw the resize bar controls between docking windows.<br />
            Default: <i>SystemColors.Control</i><p /><b>CaptionFont</b><br />
            Used when drawing text in the caption bars.<br />
            Default: <i>SystemInformation.MenuFont</i><p /><b>TabControlFont</b><br />
            Used when drawing text in the TabControl that appears when multiple content is 
            shown inside the same docking window.<br />
            Default: <i>SystemInformation.MenuFont</i><p /><b>PlainTabBorder</b><br />
            If the appearance is defined as <i>VisualStyle.Plain</i> and this <i>PlainTabBorder</i>
            property is defined then a full dumped border is drawn around the docking window content.<br />
            Default: <i>false</i><p /><b>Factory</b><br />
            Specifies the control and form classes to create within the docking windows system. The
            standard implementation class <i>DockingFactory</i> will be created in the constructor of
            the <i>DockingManager</i>. You can create your own implementation by deriving from this class
            and then providing an instance as a parameter to the <i>DockingManager</i> constructor call.<br /></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-top.gif" /></td>
            </tr>
            <tr>
              <td>
                <table border="0" cellpadding="0" cellspacing="0" width="100%" background="images/section-mid.gif">
                  <tr>
                    <td width="20"></td>
                    <td>
                      <table width="100%">
                        <tr>
                          <td height="20">
                            <a class="documentHeader" name="notifications">Notifications</a></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                        <tr class="documentMain">
                          <td valign="top" class="documentText">
                            <content xmlns="">
                              <b>ContextMenuHandler ContextMenu</b>
                              <br />
            Fired when the user right clicks on the caption area of a docking window which 
            will attempt to show a context menu. Hook into this event to either cancel it 
            altogether or to customize the menu commands presented to the user.<p /><b>ContentHidingHandler ContentHiding</b><br />
            Fired when the user causes a content object to be hidden. Either when the user 
            presses the close button on the caption bar or closes a floating form in which 
            case the event is fired for each content in the floating form. Hook into this 
            event to cancel the close operation from occuring and so preventing the user 
            from hiding a content.<p /><b>ContentHandler ContentHidden</b><br />
            Fired after a content object has been hidden and occurs from either user or 
            programmatic actions. You cannot prevent the operation occuring as this event is 
            generated after the content had already been hidden but can be used to perform 
            extra processing.<p /><b>ContentHandler ContentShown</b><br />
            Fired after a content object has been made visible and occurs from either user 
            or programmatic actions. You cannot prevent the operation occuring as this event 
            is generated after the content had already been shown but can be used to 
            perform extra processing.<p /><b>ContentHandler ContentAutoHideShowing</b><br />
            Fired when a content is in auto hidden mode and about to brought into view by sliding 
            out. This can happen when the user hovers the mouse over the small tab stubs that
            appear at the edge of the docking form. It will also fire if the action is initiated
            programmatically.<p /><b>ContentHandler ContentAutoHideClosed</b><br />
            Fired when a content that is auto hidden but currently slide out for viewing is slide
            back away from view. This can happen because the user moves the mouse away from the
            slide out content or because the focus is transferred to another control. It will also 
            fire if the action is initiated programmatically.<p /><b>TabControlCreatedHandler TabControlCreated</b><br />
            Fired whenever the docking windows code needs to create a TabControl instance 
            for use inside a docking window. When generated the control has already been 
            created and setup with the default properties, but use this event to customize 
            the properties as required.<p /><b>SaveCustomConfigHandler SaveCustomConfig</b><br />
            Fired when persisting out configuration information about the current docking
            windows layout. The event is fired at the end of the process and allows the 
            developer to add custom XML information into the output stream.<p /><b>LoadCustomConfigHandler LoadCustomConfig</b><br />
            Fired when persisting in configuration information to restore the docking
            configuration to a previously saved state. The event is fired at the end of the
            loading process and allows the developer to read back the custom data they
            saved previously.<p /><b>EventHandler LayoutChanged</b><br />
            This event is fired whenever the docking layout has been changed. So if the hide/show state, 
            the auto hidden state or docking edge/floating states change then the LayoutChanged event is 
            fired. You can use this to decide if the layout configuration needs to be saved when you 
            application exits.<p /><b>CancelEventHandler DoubleClickFloatingForm</b><br />
            This event is fired whenever the user double clicks on the title bar area of a floating form. 
            The event can be cancelled in order to prevent the default action of restoring all the Content 
            back to docking within the main form.<p /><h2>Delegate Signatures</h2><code>C#</code><pre>
  
   void ContentHandler(Content c, EventArgs cea);
   void ContentHidingHandler(Content c, CancelEventArgs cea);
   void ContextMenuHandler(ContextMenuStrip cms, CancelEventArgs cea);
   void TabControlCreatedHandler(Magic.Controls.TabControl tabControl);
   void SaveCustomConfigHandler(XmlTextWriter xmlOut);
   void LoadCustomConfigHandler(XmlTextReader xmlIn);

</pre><code>VB.NET</code><pre>

   Sub ContentHandler(Dim c As Content, Dim cea As EventArgs)
   Sub ContentHidingHandler(Dim c As Content, Dim cea As CancelEventArgs)
   Sub ContextMenuHandler(Dim pm As ContextMenuStrip, Dim cea As CancelEventArgs)
   Sub TabControlCreatedHandler(Dim tabControl As DotNetMagic.Controls.TabControl)
   Sub SaveCustomConfigHandler(Dim xmlOut As XmlTextWriter xmlOut)
   Sub LoadCustomConfigHandler(Dim xmlIn As XmlTextReader xmlIn)

</pre></content></td>
                        </tr>
                        <tr>
                          <td height="10"></td>
                        </tr>
                      </table></td>
                    <td width="20"></td>
                  </tr>
                </table></td>
            </tr>
            <tr>
              <td>
                <img src="./images/section-bottom.gif" /></td>
            </tr>
          </table></td>
      </tr>
    </table>
    <div style="position:absolute; left:20px; top:132px;">
      <a href="../readme.html" class="white">ReadMe</a>
      <span class="cyan">| </span>
      <a href="articles.html" class="white">Articles</a>
      <span class="cyan">| </span>
      <a href="contact.html" class="white">Contact</a>
    </div>
    <div style="position:absolute; left:620px; top:132px; text-align:right;">
      <span class="whitebold">Empowering the User</span>
    </div>
  </body>
</html>
