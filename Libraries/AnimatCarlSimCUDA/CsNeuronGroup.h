/**
\file	CsNeuronGroup.h

\brief	Declares the CsNeuronGroup class.
**/

#pragma once

namespace AnimatCarlSim
{

	/**
	\brief	Firing Rate Neuron model.

	\details This Neuron implements a firing rate neural model. The firing rate model is a more abstract representation
	of the neuron than an integrate and fire system. This type of model assumes that there is a linear relationship between 
	cell depolarization and firing rate. After the neuron has depolarized beyond its threshold its firing rate increases linearly between
	0 and 1	relative to the membrane potential and a gain value. Synapses inject current into post-synaptic neurons based on the firing rate.
	The synaptic weight is the amount of current to inject, and this is multiplied by the firing rate of the pre-synaptic neuron. this model also 
	has modulatory and gated synapses.<br>
	Another feature of this model is that there are a few different types of neruons. These primarily differ based on how they implement intrinsic
	currents. Intrinsic currents are currents that are internal to the neuron. An exmample of this is the pacemaker neuron that generates currents
	internally to model bursting behavior.
		
	\author	dcofer
	\date	3/29/2011
	**/
	class ANIMAT_CARL_SIM_PORT CsNeuronGroup : public AnimatSim::Node, public SpikeMonitor 
	{
	protected:
		/// Pointer to parent CsNeuralModule.
		CsNeuralModule *m_lpCsModule;

		///The number of neurons in this group
		unsigned int m_uiNeuronCount;

		//The type of these neurons. Either EXCITATORY_NEURON or INHIBITORY_NEURON
		int m_iNeuralType;

		///The group ID of this set of neurons
		int m_iGroupID;

		///The Izhikevich A parameter
		float m_fltA;

		///The standard deviation for Izhikevich parameter A
		float m_fltStdA;

		///The Izhikevich B parameter
		float m_fltB;

		///The standard deviation for Izhikevich parameter B
		float m_fltStdB;

		///The Izhikevich C parameter
		float m_fltC;

		///The standard deviation for Izhikevich parameter C
		float m_fltStdC;

		///The Izhikevich D parameter
		float m_fltD;

		///The standard deviation for Izhikevich parameter D
		float m_fltStdD;
		
		///Enables or disables conductance based neuron modelling.
		///If false the neurons in this group will use current based modelling.
		bool m_bEnableCOBA;

		///Time constant of AMPA decay (ms); for example, 5.0 
		float m_fltTauAMPA;

		///Time constant of NMDA decay (ms); for example, 150.0 
		float m_fltTauNMDA;

		///Time constant of GABAa decay (ms); for example, 6.0  
		float m_fltTauGABAa;

		///Time constant of GABAb decay (ms); for example, 150.0
		float m_fltTauGABAb;

		///Tells whether this group of neurons exhibits Short term plasticity
		bool m_bEnableSTP;

		///the increment of u due to a spike for STP
		float m_fltU;

		///the time constant for depression term for STP
		float m_fltTauDepression;

		///the time constant for facilitation term for STP
		float m_fltTauFacilitation;

		///Tells whether this group of neurons exhibits spike-timing dependent plasticity
		bool m_bEnableSTDP;

		///the max magnitude for LTP change for STDP
		float m_fltMaxLTP;

		///the decay time constant for LTP change for STDP
		float m_fltTauLTP;

		///the max magnitude for LTD change for STDP
		float m_fltMaxLTD;

		///the decay time constant for LTD change for STDP
		float m_fltTauLTD;


		///The firing rate of this entire group of neurons.
		float m_fltGroupFiringRate;

		///The total number of spikes generated by this group of neurons in the last time slice.
		float m_fltGroupTotalSpikes;
		
		///Fakes spike data for the CsNeuronDataColumn to read. This will always be Null chart value of -99999. It is mainly
		///here for it to have something to connect to. Spike data will actually be filled in later from
		///the list of spike timing data collected during the run.
		float m_fltSpikeFake;

		///If > 0 it collects data from the whole population. This is an iterator keeping track of how many things have told it to collect the whole population.
		int m_iCollectWholePopulation;

		///An array of neuron indices for individual neurons we want to collect spike data for throughout the current simulation run
		CStdMap<int, int> m_aryCollectSpikeData;

		///A map for keeping track of a spike times in ms for individual neurons in this group throughout the current simulation run.
		std::multimap<int, unsigned long> m_arySpikeTimes;

		///A map for keeping track of a spike times in ms for individual neurons in this group since the last time the spike monitors ran
		std::multimap<unsigned long, int> m_aryRecentSpikeTimes;

		///This is a copy of the last recent spike times for use by the phsyics simulation.
		std::multimap<unsigned long, int> *m_lpLastRecentSpikeTimes;

		///The last time step for which the monitor method ran.
		unsigned long m_lLastUpdateTime;

		///The last time we copied the spike times for this group.
		float m_fltLastCopySpikesTime;

		unsigned long m_lTotalSpikesCollected;

#ifndef STD_DO_NOT_ADD_BOOST
			///mutex used to try and access matches variable.
			boost::interprocess::interprocess_mutex m_AccessRecentSpikes;
#endif


	public:
		CsNeuronGroup();
		virtual ~CsNeuronGroup();

		virtual void SetCARLSimulation();

		CsNeuralModule *GetCsModule() {return m_lpCsModule;};

		virtual void NeuronCount(unsigned int iVal);
		virtual unsigned int NeuronCount();

		virtual void NeuralType(int iVal);
		virtual int NeuralType();

		virtual void GroupID(int iVal);
		virtual int GroupID();

		virtual void A(float fltVal);
		virtual float A();

		virtual void StdA(float fltVal);
		virtual float StdA();

		virtual void B(float fltVal);
		virtual float B();

		virtual void StdB(float fltVal);
		virtual float StdB();

		virtual void C(float fltVal);
		virtual float C();

		virtual void StdC(float fltVal);
		virtual float StdC();

		virtual void D(float fltVal);
		virtual float D();

		virtual void StdD(float fltVal);
		virtual float StdD();

		virtual void EnableCOBA(bool bVal);
		virtual bool EnableCOBA();

		virtual void TauAMPA(float fltVal);
		virtual float TauAMPA();

		virtual void TauNMDA(float fltVal);
		virtual float TauNMDA();

		virtual void TauGABAa(float fltVal);
		virtual float TauGABAa();

		virtual void TauGABAb(float fltVal);
		virtual float TauGABAb();

		virtual void EnableSTP(bool bVal);
		virtual bool EnableSTP();

		virtual void U(float fltVal);
		virtual float U();

		virtual void TauDepression(float fltVal);
		virtual float TauDepression();

		virtual void TauFacilitation(float fltVal);
		virtual float TauFacilitation();

		virtual void EnableSTDP(bool bVal);
		virtual bool EnableSTDP();

		virtual void MaxLTP(float fltVal);
		virtual float MaxLTP();

		virtual void TauLTP(float fltVal);
		virtual float TauLTP();

		virtual void MaxLTD(float fltVal);
		virtual float MaxLTD();

		virtual void TauLTD(float fltVal);
		virtual float TauLTD();

		virtual void CollectFromWholePopulation(bool bVal);
		virtual bool CollectFromWholePopulation();

		virtual std::multimap<int, unsigned long> *SpikeTimes();
		virtual std::multimap<unsigned long, int> *RecentSpikeTimes();
		virtual std::multimap<unsigned long, int> *LastRecentSpikeTimes();

		virtual float LastCopySpikesTime() {return m_fltLastCopySpikesTime;}
		
#ifndef STD_DO_NOT_ADD_BOOST
			///mutex used to try and access matches variable.
		boost::interprocess::interprocess_mutex *AccessRecentSpikes() {return &m_AccessRecentSpikes;};
#endif

		virtual void CopyRecentSpikeTimes();
		virtual void ClearLastRecentSpikeTimes();

		virtual void IncrementCollectSpikeDataForNeuron(int iIdx);
		virtual void DecrementCollectSpikeDataForNeuron(int iIdx);
		virtual bool CollectingSpikeDataForNeuron(int iIdx);

		virtual void update(CpuSNN* s, int grpId, unsigned int* NeuronIds, unsigned int *timeCounts, unsigned int total_spikes, float firing_Rate);

		virtual void AddExternalNodeInput(int iTargetDataType, float fltInput);
		virtual void Copy(CStdSerialize *lpSource);

		virtual void SetSystemPointers(Simulator *lpSim, Structure *lpStructure, NeuralModule *lpModule, Node *lpNode, bool bVerify);
		virtual void VerifySystemPointers();
		virtual void Initialize();
		virtual void StepSimulation();
		virtual void ResetSimulation();

#pragma region DataAccesMethods
		virtual bool SetData(const std::string &strDataType, const std::string &strValue, bool bThrowError = true);
		virtual void QueryProperties(CStdPtrArray<TypeProperty> &aryProperties);
		virtual float *GetDataPointer(const std::string &strDataType);
#pragma endregion

		virtual void Load(CStdXml &oXml);
	};

}				//AnimatCarlSim
