// ***************************************************************************
//
//   Generated automatically by genwrapper.
//   Please DO NOT EDIT this file!
//
// ***************************************************************************

#include <osgIntrospection/ReflectionMacros>
#include <osgIntrospection/TypedMethodInfo>
#include <osgIntrospection/StaticMethodInfo>
#include <osgIntrospection/Attributes>

#include <osg/DeleteHandler>
#include <osg/Referenced>

// Must undefine IN and OUT macros defined in Windows headers
#ifdef IN
#undef IN
#endif
#ifdef OUT
#undef OUT
#endif

TYPE_NAME_ALIAS(std::pair< int COMMA  const osg::Referenced * >, osg::DeleteHandler::FrameNumberObjectPair)

TYPE_NAME_ALIAS(std::list< osg::DeleteHandler::FrameNumberObjectPair >, osg::DeleteHandler::ObjectsToDeleteList)

BEGIN_OBJECT_REFLECTOR(osg::DeleteHandler)
	I_DeclaringFile("osg/DeleteHandler");
	I_ConstructorWithDefaults1(IN, int, numberOfFramesToRetainObjects, 0,
	                           Properties::NON_EXPLICIT,
	                           ____DeleteHandler__int,
	                           "",
	                           "");
	I_Method1(void, setNumFramesToRetainObjects, IN, int, numberOfFramesToRetainObjects,
	          Properties::NON_VIRTUAL,
	          __void__setNumFramesToRetainObjects__int,
	          "Set the number of frames to retain objects that are have been requested for deletion. ",
	          "When set to zero objects are deleted immediately, by set to 1 there are kept around for an extra frame etc. The ability to retain objects for several frames is useful to prevent premature deletion when objects are still be used the graphics threads that are using double buffering of rendering data structures with non ref_ptr<> pointers to scene graph elements. ");
	I_Method0(int, getNumFramesToRetainObjects,
	          Properties::NON_VIRTUAL,
	          __int__getNumFramesToRetainObjects,
	          "",
	          "");
	I_Method1(void, setFrameNumber, IN, int, frameNumber,
	          Properties::NON_VIRTUAL,
	          __void__setFrameNumber__int,
	          "Set the current frame number so that subsequent deletes get tagged as associated with this frame. ",
	          "");
	I_Method0(int, getFrameNumber,
	          Properties::NON_VIRTUAL,
	          __int__getFrameNumber,
	          "Get the current frame number. ",
	          "");
	I_Method1(void, doDelete, IN, const osg::Referenced *, object,
	          Properties::NON_VIRTUAL,
	          __void__doDelete__C5_Referenced_P1,
	          "",
	          "");
	I_Method0(void, flush,
	          Properties::VIRTUAL,
	          __void__flush,
	          "Flush objects that ready to be fully deleted. ",
	          "");
	I_Method0(void, flushAll,
	          Properties::VIRTUAL,
	          __void__flushAll,
	          "Flush all objects that the DeleteHandler holds. ",
	          "Note, this should only be called if there are no threads running with non ref_ptr<> pointers, such as graphics threads. ");
	I_Method1(void, requestDelete, IN, const osg::Referenced *, object,
	          Properties::VIRTUAL,
	          __void__requestDelete__C5_osg_Referenced_P1,
	          "Request the deletion of an object. ",
	          "Depending on users implementation of DeleteHandler, the delete of the object may occur straight away or be delayed until doDelete is called. The default implementation does a delete straight away. ");
	I_ProtectedConstructor1(IN, const osg::DeleteHandler &, x,
	                        Properties::NON_EXPLICIT,
	                        ____DeleteHandler__C5_DeleteHandler_R1,
	                        "",
	                        "");
	I_SimpleProperty(int, FrameNumber, 
	                 __int__getFrameNumber, 
	                 __void__setFrameNumber__int);
	I_SimpleProperty(int, NumFramesToRetainObjects, 
	                 0, 
	                 __void__setNumFramesToRetainObjects__int);
END_REFLECTOR

STD_LIST_REFLECTOR(std::list< osg::DeleteHandler::FrameNumberObjectPair >)

STD_PAIR_REFLECTOR(std::pair< int COMMA  const osg::Referenced * >)

